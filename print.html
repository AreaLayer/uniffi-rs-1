<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>The UniFFI user guide</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="Overview.html">Overview</a></li><li class="chapter-item expanded "><a href="Motivation.html"><strong aria-hidden="true">1.</strong> Motivation</a></li><li class="chapter-item expanded "><a href="Getting_started.html"><strong aria-hidden="true">2.</strong> Tutorial</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="tutorial/Prerequisites.html"><strong aria-hidden="true">2.1.</strong> Prerequisites</a></li><li class="chapter-item expanded "><a href="tutorial/udl_file.html"><strong aria-hidden="true">2.2.</strong> Describing the interface</a></li><li class="chapter-item expanded "><a href="tutorial/Rust_scaffolding.html"><strong aria-hidden="true">2.3.</strong> Generating the Rust scaffolding code</a></li><li class="chapter-item expanded "><a href="tutorial/foreign_language_bindings.html"><strong aria-hidden="true">2.4.</strong> Generating the foreign-language bindings</a></li></ol></li><li class="chapter-item expanded "><a href="udl_file_spec.html"><strong aria-hidden="true">3.</strong> The UDL file</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="udl/namespace.html"><strong aria-hidden="true">3.1.</strong> Namespace</a></li><li class="chapter-item expanded "><a href="udl/builtin_types.html"><strong aria-hidden="true">3.2.</strong> Built-in types</a></li><li class="chapter-item expanded "><a href="udl/enumerations.html"><strong aria-hidden="true">3.3.</strong> Enumerations</a></li><li class="chapter-item expanded "><a href="udl/structs.html"><strong aria-hidden="true">3.4.</strong> Structs/Dictionaries</a></li><li class="chapter-item expanded "><a href="udl/functions.html"><strong aria-hidden="true">3.5.</strong> Functions</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="udl/errors.html"><strong aria-hidden="true">3.5.1.</strong> Throwing errors</a></li></ol></li><li class="chapter-item expanded "><a href="udl/interfaces.html"><strong aria-hidden="true">3.6.</strong> Interfaces/Objects</a></li><li class="chapter-item expanded "><a href="udl/callback_interfaces.html"><strong aria-hidden="true">3.7.</strong> Callback Interfaces</a></li><li class="chapter-item expanded "><a href="udl/ext_types.html"><strong aria-hidden="true">3.8.</strong> External Types</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="udl/ext_types_external.html"><strong aria-hidden="true">3.8.1.</strong> Declaring External Types</a></li><li class="chapter-item expanded "><a href="udl/custom_types.html"><strong aria-hidden="true">3.8.2.</strong> Declaring Custom Types</a></li></ol></li><li class="chapter-item expanded "><a href="udl/docstrings.html"><strong aria-hidden="true">3.9.</strong> Docstrings</a></li></ol></li><li class="chapter-item expanded "><a href="proc_macro/index.html"><strong aria-hidden="true">4.</strong> Procedural Macros: Attributes and Derives</a></li><li class="chapter-item expanded "><a href="futures.html"><strong aria-hidden="true">5.</strong> Futures and async support</a></li><li class="chapter-item expanded "><a href="bindings.html"><strong aria-hidden="true">6.</strong> Bindings</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="bindings.html"><strong aria-hidden="true">6.1.</strong> Customizing binding generation</a></li><li class="chapter-item expanded "><a href="foreign_traits.html"><strong aria-hidden="true">6.2.</strong> Implementing Rust traits in foreign bindings</a></li><li class="chapter-item expanded "><a href="kotlin/configuration.html"><strong aria-hidden="true">6.3.</strong> Kotlin</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="kotlin/gradle.html"><strong aria-hidden="true">6.3.1.</strong> Integrating with Gradle</a></li><li class="chapter-item expanded "><a href="kotlin/lifetimes.html"><strong aria-hidden="true">6.3.2.</strong> Kotlin Lifetimes</a></li></ol></li><li class="chapter-item expanded "><a href="swift/overview.html"><strong aria-hidden="true">6.4.</strong> Swift</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="swift/configuration.html"><strong aria-hidden="true">6.4.1.</strong> Configuration</a></li><li class="chapter-item expanded "><a href="swift/module.html"><strong aria-hidden="true">6.4.2.</strong> Building a Swift module</a></li><li class="chapter-item expanded "><a href="swift/xcode.html"><strong aria-hidden="true">6.4.3.</strong> Integrating with Xcode</a></li></ol></li><li class="chapter-item expanded "><a href="python/configuration.html"><strong aria-hidden="true">6.5.</strong> Python</a></li></ol></li><li class="chapter-item expanded "><li class="part-title">Internals</li><li class="chapter-item expanded "><a href="internals/design_principles.html"><strong aria-hidden="true">7.</strong> Design Principles</a></li><li class="chapter-item expanded "><a href="internals/crates.html"><strong aria-hidden="true">8.</strong> Navigating the Code</a></li><li class="chapter-item expanded "><a href="internals/lifting_and_lowering.html"><strong aria-hidden="true">9.</strong> Lifting, Lowering, and Serialization</a></li><li class="chapter-item expanded "><a href="internals/object_references.html"><strong aria-hidden="true">10.</strong> Managing Object References</a></li><li class="chapter-item expanded "><a href="internals/rendering_foreign_bindings.html"><strong aria-hidden="true">11.</strong> Rendering Foreign Bindings</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The UniFFI user guide</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="uniffi"><a class="header" href="#uniffi">UniFFI</a></h1>
<p>UniFFI is a tool that automatically generates foreign-language bindings targeting Rust libraries.
The repository can be found on <a href="https://github.com/mozilla/uniffi-rs/">github</a>.
It fits in the practice of consolidating business logic in a single Rust library while targeting multiple platforms, making it simpler to develop and maintain a cross-platform codebase.
Note that this tool will not help you ship a Rust library to these platforms, but simply not have to write bindings code by hand. <a href="https://i.kym-cdn.com/photos/images/newsfeed/000/572/078/d6d.jpg">Related</a>.</p>
<h2 id="design"><a class="header" href="#design">Design</a></h2>
<p>UniFFI requires to write an Interface Definition Language (based on <a href="https://heycam.github.io/webidl/">WebIDL</a>) file describing the methods and data structures available to the targeted languages.
This .udl (UniFFI Definition Language) file, whose definitions must match with the exposed Rust code, is then used to generate Rust <em>scaffolding</em> code and foreign-languages <em>bindings</em>. This process can take place either during the build process or be manually initiated by the developer.</p>
<p><img src="./uniffi_diagram.png" alt="uniffi diagram" /></p>
<h2 id="supported-languages"><a class="header" href="#supported-languages">Supported languages</a></h2>
<ul>
<li>Kotlin</li>
<li>Swift</li>
<li>Python</li>
<li>Ruby</li>
</ul>
<h2 id="third-party-foreign-language-bindings"><a class="header" href="#third-party-foreign-language-bindings">Third-party foreign language bindings</a></h2>
<ul>
<li><a href="https://gitlab.com/trixnity/uniffi-kotlin-multiplatform-bindings">Kotlin Multiplatform</a></li>
<li><a href="https://github.com/NordSecurity/uniffi-bindgen-go">Go bindings</a></li>
<li><a href="https://github.com/NordSecurity/uniffi-bindgen-cs">C# bindings</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="what"><a class="header" href="#what">What?</a></h2>
<p>We're interested in building re-useable components for sync- and storage-related browser
functionality - things like <a href="https://github.com/mozilla/application-services/tree/main/components/logins">storing and syncing passwords</a>,
<a href="https://github.com/mozilla/application-services/tree/main/components/places">working with bookmarks</a> and
<a href="https://github.com/mozilla/application-services/tree/main/components/fxa-client">signing in to your Firefox Account</a>.</p>
<p>We want to write the code for these components once, in Rust. We want to easily re-use these components from
all the different languages and on all the different platforms for which we build browsers, which currently
includes JavaScript for PCs, Kotlin for Android, and Swift for iOS.</p>
<p>And of course, we want to do this in a way that's convenient, maintainable, and difficult to mess up.</p>
<h2 id="how"><a class="header" href="#how">How?</a></h2>
<p>In an aspirational world, we could get this kind of easy cross-language interop for
free using <a href="https://rustwasm.github.io/docs/wasm-bindgen/">wasm_bindgen</a> and
<a href="https://hacks.mozilla.org/2019/08/webassembly-interface-types/">webassembly interface types</a> -
imagine writing an API in Rust, annotating it with some <code>#[wasm_bindgen]</code> macros,
compiling it into a webassembly bundle, and being able to import and use that bundle
from any target language, complete with a rich high-level API!</p>
<p>That kind of tooling is not available to shipping applications today, but that doesn't
mean we can't take a small step in that general direction while the Rust and Wasm ecosystem
continues to evolve.</p>
<p>Using UniFFI, you can:</p>
<ul>
<li>Implement your software component as a <code>cdylib</code> crate in Rust; let's say the code is in <code>./src/lib.rs</code>.</li>
<li>Specify the desired component API using an <em>Interface Definition Language</em> (specifically, a variant of WebIDL) in a separate file like <code>./src/lib.udl</code>.</li>
<li>Run <code>uniffi-bindgen scaffolding ./src/lib.udl</code> to generate a bunch of boilerplate rust code that exposes this API as a C-compatible FFI layer,
and include it as part of your crate.</li>
<li><code>cargo build</code> your crate as normal to produce a shared library.</li>
<li>Run <code>uniffi-bindgen generate ./src/lib.udl -l kotlin</code> to generate a Kotlin library that can load your shared library
and expose it to Kotlin code using your nice high-level component API!
<ul>
<li>Or <code>-l swift</code> or <code>-l python</code> to produce bindings for other languages.</li>
</ul>
</li>
</ul>
<h2 id="why"><a class="header" href="#why">Why?</a></h2>
<p>There are plenty of potential ways to solve this problem, and the one that's right for us might not
be right for you. You can read a little more about the considerations and trade-offs
that lead to the current approach in our <a href="https://github.com/mozilla/uniffi-rs/tree/main/docs/adr/README.md">Architecture Decision Records</a>,
starting with <a href="https://github.com/mozilla/uniffi-rs/tree/main/docs/adr/0000-whats-the-big-idea.md">this motivational document</a>.</p>
<h2 id="why-not"><a class="header" href="#why-not">Why Not?</a></h2>
<p>We hope UniFFI will be useful to you! But if you're considering it for your project then
here are some tradeoffs you should keep in mind:</p>
<ul>
<li>UniFFI makes it easy to produce &quot;good enough&quot; bindings into Rust from several different target languages.
If you want to call Rust code from just one foreign language, there may be a language-specific
bindings tool that provides more features and better performance.</li>
<li>The project is evolving fast, because it's being developed concurrently with its
primary consumers. You should be prepared for frequent releases and non-trivial API churn
(but we'll use semantic versioning to signal breaking changes).</li>
<li>UniFFI doesn't provide an end-to-end packaging solution for your Rust code and its generated bindings.
For example, it'll help you generate Kotlin bindings to call into Rust, but it won't help you with
compiling the Rust code to run on Android or with packaging the bindings into an <code>.aar</code> bundle
(but it might be useful as a building-block for such a tool!).</li>
</ul>
<p>We also have a list of <a href="./internals/design_principles.html">design principles</a> that might help
you decide whether this project is a good fit for your needs.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="getting-started"><a class="header" href="#getting-started">Getting started</a></h1>
<p>Say your company has a simple <code>math</code> crate with the following <code>lib.rs</code>:</p>
<pre><code class="language-rust">fn add(a: u32, b: u32) -&gt; u32 {
    a + b
}</code></pre>
<p>And top brass would like you to expose this <em>business-critical</em> operation to Kotlin and Swift.<br />
<strong>Don't panic!</strong> We will show you how do that using UniFFI.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="prerequisites"><a class="header" href="#prerequisites">Prerequisites</a></h1>
<h2 id="add-uniffi-as-a-dependency-and-build-dependency"><a class="header" href="#add-uniffi-as-a-dependency-and-build-dependency">Add <code>uniffi</code> as a dependency and build-dependency</a></h2>
<p>In your crate's <code>Cargo.toml</code> add:</p>
<pre><code class="language-toml">[dependencies]
uniffi = { version = &quot;[latest-version]&quot; }

[build-dependencies]
uniffi = { version = &quot;[latest-version]&quot;, features = [ &quot;build&quot; ] }
</code></pre>
<p>UniFFI has not reached version <code>1.0</code> yet.  Versions are typically specified as <code>0.[minor-version]</code>.</p>
<h2 id="build-your-crate-as-a-cdylib"><a class="header" href="#build-your-crate-as-a-cdylib">Build your crate as a cdylib</a></h2>
<p>Ensure your crate builds as a <code>cdylib</code> by adding</p>
<pre><code class="language-toml">[lib]
crate-type = [&quot;cdylib&quot;]
name = &quot;&lt;library name&gt;&quot;
</code></pre>
<p>to your crate's <code>Cargo.toml</code>.</p>
<p><strong>Note:</strong> You also need to add <code>staticlib</code> crate type if you target iOS.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-udl-file"><a class="header" href="#the-udl-file">The UDL file</a></h1>
<p>We describe in a UDL (a type of IDL, Interface Definition Language) file <em>what</em> is exposed and available to foreign-language bindings. In this case, we are only playing with primitive types (<code>u32</code>) and not custom data structures but we still want to expose the <code>add</code> method.<br />
Let's create a <code>math.udl</code> file in the <code>math</code> crate's <code>src/</code> folder:</p>
<pre><code class="language-idl">namespace math {
  u32 add(u32 a, u32 b);
};
</code></pre>
<p>Here you can note multiple things:</p>
<ul>
<li>The <code>namespace</code> directive: it will be the name of your Kotlin/Swift package. It <strong>must</strong> be present in any udl file, even if there ain't any exposed function (e.g. <code>namespace foo {}</code>).</li>
<li>The <code>add</code> function is in the <code>namespace</code> block. That's because on the Rust side it is a top-level <em>function</em>, we will see later how to to handle <em>methods</em>.</li>
<li>Rust's <code>u32</code> is also UDL's <code>u32</code>, but it is not always true! See the <a href="tutorial/../udl/builtin_types.html">Built-in Types</a> chapter for more information on mapping types between Rust and UDL.</li>
</ul>
<p><strong>Note:</strong> If any of the things you expose in the <code>udl</code> file do not have an equivalent in your Rust crate, you will get a hard error. Try changing the <code>u32</code> result type to <code>u64</code> and see what happens!</p>
<p><strong>Note</strong> It's also possible to use <a href="tutorial/../proc_macro/index.html">Rust procmacros</a> to describe your interface and you can avoid
UDL files entirely if you choose.
Unfortunately the docs aren't quite as good for that yet though.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rust-scaffolding"><a class="header" href="#rust-scaffolding">Rust scaffolding</a></h1>
<h2 id="rust-scaffolding-code"><a class="header" href="#rust-scaffolding-code">Rust scaffolding code</a></h2>
<p>Now we generate some Rust helper code to make the <code>add</code> method available to foreign-language bindings.</p>
<p>First, add <code>uniffi</code> to your crate as both a dependency and build-dependency.  Enable the <code>build</code> feature for the build-dependencies.  This adds the runtime support code that powers UniFFI and build-time support for generating the Rust scaffolding code.</p>
<pre><code class="language-toml">[dependencies]
uniffi = &quot;0.XX.0&quot;

[build-dependencies]
uniffi = { version = &quot;0.XX.0&quot;, features = [&quot;build&quot;] }
</code></pre>
<p>As noted in <a href="tutorial/udl_file.html">Describing the interface</a>, UniFFI currently supports two methods of interface definitions: UDL files and proc macros.
If you are using only proc macros, you can skip some boilerplate in your crate setup as well.</p>
<h3 id="setup-for-crates-using-udl"><a class="header" href="#setup-for-crates-using-udl">Setup for crates using UDL</a></h3>
<p>Crates using UDL need a <code>build.rs</code> file next to <code>Cargo.toml</code>. This uses <code>uniffi</code> to generate the Rust scaffolding code.</p>
<pre><code class="language-rust">fn main() {
    uniffi::generate_scaffolding(&quot;src/math.udl&quot;).unwrap();
}</code></pre>
<p>Lastly, we include the generated scaffolding code in our <code>lib.rs</code> using this handy macro:</p>
<pre><code class="language-rust">uniffi::include_scaffolding!(&quot;math&quot;);</code></pre>
<p><strong>Note:</strong> The file name is always <code>&lt;namespace&gt;.uniffi.rs</code>.</p>
<h3 id="setup-for-crates-using-only-proc-macros"><a class="header" href="#setup-for-crates-using-only-proc-macros">Setup for crates using only proc macros</a></h3>
<p>If you are only using proc macros, you can skip <code>build.rs</code> entirely!
All you need to do is add this to the top of <code>lib.rs</code>
NOTE: This function takes an optional parameter, the <a href="tutorial/../udl/namespace.html"><code>namespace</code></a> used by the component.
If not specified, the crate name will be used as the namespace.</p>
<pre><code class="language-rust">uniffi::setup_scaffolding!();</code></pre>
<p><strong>⚠ Warning ⚠</strong> Do not call both <code>uniffi::setup_scaffolding!()</code> and <code>uniffi::include_scaffolding!!()</code> in the same crate.</p>
<h3 id="libraries-that-depend-on-uniffi-components"><a class="header" href="#libraries-that-depend-on-uniffi-components">Libraries that depend on UniFFI components</a></h3>
<p>Suppose you want to create a shared library that includes one or more
components using UniFFI. The typical way to achieve this is to create a new
crate that depends on the component crates.  However, this can run into
<a href="https://github.com/rust-lang/rust/issues/50007">rust-lang#50007</a>.  Under
certain circumstances, the scaffolding functions that the component crates
export do not get re-exported by the dependent crate.</p>
<p>Use the <code>uniffi_reexport_scaffolding!</code> macro to work around this issue.  If your
library depends on <code>foo_component</code>, then add
<code>foo_component::uniffi_reexport_scaffolding!();</code> to your <code>lib.rs</code> file and
UniFFI will add workaround code that forces the functions to be re-exported.</p>
<p>Each scaffolding function contains a hash that's derived from the UDL file.
This avoids name collisions when combining multiple UniFFI components into
one library.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="foreign-language-bindings"><a class="header" href="#foreign-language-bindings">Foreign-language bindings</a></h1>
<p>As stated in the <a href="tutorial/../Overview.html">Overview</a>, this library and tutorial does not cover <em>how</em> to ship a Rust library on mobile, but how to generate bindings for it, so this section will only cover that.</p>
<h2 id="creating-the-bindgen-binary"><a class="header" href="#creating-the-bindgen-binary">Creating the bindgen binary</a></h2>
<p>First, make sure you have installed all the <a href="tutorial/./Prerequisites.html">prerequisites</a>.</p>
<p>Ideally you would then run the <code>uniffi-bindgen</code> binary from the <code>uniffi</code> crate to generate your bindings.  However, this
is only available with <a href="https://doc.rust-lang.org/cargo/reference/unstable.html#artifact-dependencies">Cargo nightly</a>.
To work around this, you need to create a binary in your project that does the same thing.</p>
<p>Add the following to your <code>Cargo.toml</code>:</p>
<pre><code class="language-toml">[[bin]]
# This can be whatever name makes sense for your project, but the rest of this tutorial assumes uniffi-bindgen.
name = &quot;uniffi-bindgen&quot;
path = &quot;uniffi-bindgen.rs&quot;
</code></pre>
<p>Create <code>uniffi-bindgen.rs</code>:</p>
<pre><code class="language-rust">fn main() {
    uniffi::uniffi_bindgen_main()
}</code></pre>
<p>You can now run <code>uniffi-bindgen</code> from your project using <code>cargo run --features=uniffi/cli --bin uniffi-bindgen [args]</code></p>
<h3 id="multi-crate-workspaces"><a class="header" href="#multi-crate-workspaces">Multi-crate workspaces</a></h3>
<p>If your project consists of multiple crates in a Cargo workspace, then the process outlined above would require you
creating a binary for each crate that uses UniFFI.  You can avoid this by creating a separate crate for running <code>uniffi-bindgen</code>:</p>
<ul>
<li>Name the crate <code>uniffi-bindgen</code></li>
<li>Add this dependency to <code>Cargo.toml</code>: <code>uniffi = {version = &quot;0.XX.0&quot;, features = [&quot;cli&quot;] }</code></li>
<li>Follow the steps from the previous section to add the <code>uniffi-bindgen</code> binary target</li>
</ul>
<p>Then your can run <code>uniffi-bindgen</code> from any create in your project using <code>cargo run -p uniffi-bindgen [args]</code></p>
<h2 id="running-uniffi-bindgen-using-a-library-file-recommended"><a class="header" href="#running-uniffi-bindgen-using-a-library-file-recommended">Running uniffi-bindgen using a library file (RECOMMENDED)</a></h2>
<p>Use <code>generate --library</code> to generate foreign bindings by using a cdylib file built for your library.
This flag was added in UniFFI 0.24 and can be more convenient than specifying the UDL file -- especially when multiple UniFFI-ed crates are built together in one library.
The plan is to make library mode the default in a future UniFFI version, and it is highly recommended to specify the flag for now (because some features simply don't work otherwise).</p>
<p>Taking <code>example/arithmetic</code> as an example, you can generate the bindings with:</p>
<pre><code>cargo build --release
cargo run --bin uniffi-bindgen generate --library target/release/libarithmetical.so --language kotlin --out-dir out
</code></pre>
<p>Then check out the <code>out</code> directory.</p>
<p>When using library mode, if multiple crates get built into the library that use UniFFI, all will have bindings generated for them.</p>
<p>Library mode comes with some extra requirements:</p>
<ul>
<li>It must be run from within the cargo workspace of your project</li>
<li>Each crate must use exactly 1 UDL file when compiling the Rust library.  However, crates can have
multiple UDL files as long as they ensure only one is used for any particular build,
e.g. by using feature flags.</li>
<li>Rust sources must use <code>uniffi::include_scaffolding!</code> to include the scaffolding code.</li>
</ul>
<h2 id="running-uniffi-bindgen-with-a-single-udl-file"><a class="header" href="#running-uniffi-bindgen-with-a-single-udl-file">Running uniffi-bindgen with a single UDL file</a></h2>
<p>Use the <code>generate</code> command to generate bindings by specifying a UDL file.</p>
<h3 id="kotlin"><a class="header" href="#kotlin">Kotlin</a></h3>
<p>From the <code>example/arithmetic</code> directory, run:</p>
<pre><code>cargo run --bin uniffi-bindgen generate src/arithmetic.udl --language kotlin
</code></pre>
<p>then have a look at <code>src/uniffi/arithmetic/arithmetic.kt</code></p>
<h3 id="swift"><a class="header" href="#swift">Swift</a></h3>
<p>Run</p>
<pre><code>cargo run --bin uniffi-bindgen generate src/arithmetic.udl --language swift
</code></pre>
<p>then check out <code>src/arithmetic.swift</code></p>
<p>Note that these commands could be integrated as part of your gradle/Xcode build process.</p>
<p>This is it, you have an MVP integration of UniFFI in your project.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-udl-file-1"><a class="header" href="#the-udl-file-1">The UDL file</a></h1>
<p>This file defines which functions, methods and types are exposed to the foreign-language bindings.</p>
<pre><code class="language-udl">namespace sprites {
  Point translate([ByRef] Point position, Vector direction);
};

dictionary Point {
  double x;
  double y;
};

dictionary Vector {
  double dx;
  double dy;
};

interface Sprite {
  constructor(Point? initial_position);
  Point get_position();
  void move_to(Point position);
  void move_by(Vector direction);
};
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="namespace"><a class="header" href="#namespace">Namespace</a></h1>
<p>Every UDL file <em>must</em> have a <code>namespace</code> block:</p>
<pre><code class="language-idl">namespace math {
  double exp(double a);
};
</code></pre>
<p>It serves multiple purposes:</p>
<ul>
<li>It identifies the name of the generated Rust scaffolding file <code>&lt;namespace&gt;.uniffi.rs</code>.</li>
<li>It identifies the package name of the generated foreign-language bindings (e.g. <code>uniffi.&lt;namespace&gt;</code> in Kotlin)</li>
<li>It also contains all <a href="udl/./functions.html">top-level <em>functions</em></a> that get exposed to foreign-language bindings.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="built-in-types"><a class="header" href="#built-in-types">Built-in types</a></h1>
<p>The following built-in types can be passed as arguments/returned by Rust methods:</p>
<div class="table-wrapper"><table><thead><tr><th>Rust type</th><th>UDL type</th><th>Notes</th></tr></thead><tbody>
<tr><td><code>bool</code></td><td><code>boolean</code></td><td></td></tr>
<tr><td><code>u8/i8..u64/i64</code></td><td><code>u8/i8..u64/i64</code></td><td></td></tr>
<tr><td><code>f32</code></td><td><code>float</code></td><td></td></tr>
<tr><td><code>f64</code></td><td><code>double</code></td><td></td></tr>
<tr><td><code>String</code></td><td><code>string</code></td><td></td></tr>
<tr><td><code>Vec&lt;u8&gt;</code></td><td><code>bytes</code></td><td>Different from <code>sequence&lt;u8&gt;</code> only in foreign type mappings</td></tr>
<tr><td><code>SystemTime</code></td><td><code>timestamp</code></td><td>Precision may be lost when converting to Python and Swift types</td></tr>
<tr><td><code>Duration  </code></td><td><code>duration</code></td><td>Precision may be lost when converting to Python and Swift types</td></tr>
<tr><td><code>&amp;T</code></td><td><code>[ByRef] T</code></td><td>This works for <code>&amp;str</code> and <code>&amp;[T]</code></td></tr>
<tr><td><code>Option&lt;T&gt;</code></td><td><code>T?</code></td><td></td></tr>
<tr><td><code>Vec&lt;T&gt;</code></td><td><code>sequence&lt;T&gt;</code></td><td></td></tr>
<tr><td><code>HashMap&lt;K, V&gt;</code></td><td><code>record&lt;K, T&gt;</code></td><td></td></tr>
<tr><td><code>()</code></td><td><code>void</code></td><td>Empty return</td></tr>
<tr><td><code>Result&lt;T, E&gt;</code></td><td>N/A</td><td>See <a href="udl/./errors.html">Errors</a> section</td></tr>
</tbody></table>
</div>
<p>And of course you can use your own types, which is covered in the following sections.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="enumerations"><a class="header" href="#enumerations">Enumerations</a></h1>
<p>An enumeration defined in Rust code as</p>
<pre><code class="language-rust">enum Animal {
    Dog,
    Cat,
}</code></pre>
<p>Can be exposed in the UDL file with:</p>
<pre><code class="language-idl">enum Animal {
  &quot;Dog&quot;,
  &quot;Cat&quot;,
};
</code></pre>
<h2 id="enums-with-fields"><a class="header" href="#enums-with-fields">Enums with fields</a></h2>
<p>Enumerations with associated data require a different syntax,
due to the limitations of using WebIDL as the basis for UniFFI's interface language.
An enum like this in Rust:</p>
<pre><code class="language-rust">enum IpAddr {
  V4 {q1: u8, q2: u8, q3: u8, q4: u8},
  V6 {addr: string},
}</code></pre>
<p>Can be exposed in the UDL file with:</p>
<pre><code class="language-idl">[Enum]
interface IpAddr {
  V4(u8 q1, u8 q2, u8 q3, u8 q4);
  V6(string addr);
};
</code></pre>
<p>Only enums with named fields are supported by this syntax.</p>
<h2 id="remote-non-exhaustive-enums"><a class="header" href="#remote-non-exhaustive-enums">Remote, non-exhaustive enums</a></h2>
<p>One corner case is an enum that's:</p>
<ul>
<li>Defined in another crate.</li>
<li>Has the <a href="https://doc.rust-lang.org/reference/attributes/type_system.html#the-non_exhaustive-attribute">non_exhaustive` attribute</a>.</li>
</ul>
<p>In this case, UniFFI needs to generate a default arm when matching against the enum variants, or else a compile error will be generated.
Use the <code>[NonExhaustive]</code> attribute to handle this case:</p>
<pre><code class="language-idl">[Enum]
[NonExhaustive]
interface Message {
  Send(u32 from, u32 to, string contents);
  Quit();
};
</code></pre>
<p><strong>Note:</strong> since UniFFI generates a default arm, if you leave out a variant, or if the upstream crate adds a new variant, this won't be caught at compile time.
Any attempt to pass that variant across the FFI will result in a panic.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="structsdictionaries"><a class="header" href="#structsdictionaries">Structs/Dictionaries</a></h1>
<p>Dictionaries are how UniFFI represents structured data.
They consist of one of more named <em>fields</em>, each of which holds a value of a particular type.
Think of them like a Rust struct without any methods.</p>
<p>A Rust struct like this:</p>
<pre><code class="language-rust no_run">struct TodoEntry {
    done: bool,
    due_date: u64,
    text: String,
}</code></pre>
<p>Can be exposed via UniFFI using UDL like this:</p>
<pre><code class="language-idl">dictionary TodoEntry {
    boolean done;
    u64 due_date;
    string text;
};
</code></pre>
<p>The fields in a dictionary can be of almost any type, including objects or other dictionaries.
The current limitations are:</p>
<ul>
<li>They cannot recursively contain another instance of the <em>same</em> dictionary type.</li>
<li>They cannot contain references to callback interfaces.</li>
</ul>
<h2 id="fields-holding-object-references"><a class="header" href="#fields-holding-object-references">Fields holding Object References</a></h2>
<p>If a dictionary contains a field whose type is an <a href="udl/./interfaces.html">interface</a>, then that
field will hold a <em>reference</em> to an underlying instance of a Rust struct. The Rust code for
working with such fields must store them as an <code>Arc</code> in order to help properly manage the
lifetime of the instance. So if the UDL interface looked like this:</p>
<pre><code class="language-idl">interface User {
    // Some sort of &quot;user&quot; object that can own todo items
};

dictionary TodoEntry {
    User owner;
    string text;
}
</code></pre>
<p>Then the corresponding Rust code would need to look like this:</p>
<pre><code class="language-rust no_run">struct TodoEntry {
    owner: std::sync::Arc&lt;User&gt;,
    text: String,
}</code></pre>
<p>Depending on the language, the foreign-language bindings may also need to be aware of
these embedded references. For example in Kotlin, each Object instance must be explicitly
destroyed to avoid leaking the underlying memory, and this also applies to Objects stored
in record fields.</p>
<p>You can read more about managing object references in the section on <a href="udl/./interfaces.html">interfaces</a>.</p>
<h2 id="default-values-for-fields"><a class="header" href="#default-values-for-fields">Default values for fields</a></h2>
<p>Fields can be specified with a default value:</p>
<pre><code class="language-idl">dictionary TodoEntry {
    boolean done = false;
    string text;
};
</code></pre>
<p>The corresponding generated Kotlin code would be equivalent to:</p>
<pre><code class="language-kotlin">data class TodoEntry (
    var done: Boolean = false,
    var text: String
)  {
    // ...
}
</code></pre>
<p>This works for Swift and Python targets too.
If not set otherwise the default value for a field is used when constructing the Rust struct.</p>
<h2 id="optional-fields-and-default-values"><a class="header" href="#optional-fields-and-default-values">Optional fields and default values</a></h2>
<p>Fields can be made optional using a <code>T?</code> type.</p>
<pre><code class="language-idl">dictionary TodoEntry {
    boolean done;
    string? text;
};
</code></pre>
<p>The corresponding Rust struct would need to look like this:</p>
<pre><code class="language-rust no_run">struct TodoEntry {
    done: bool,
    text: Option&lt;String&gt;,
}</code></pre>
<p>The corresponding generated Kotlin code would be equivalent to:</p>
<pre><code class="language-kotlin">data class TodoEntry (
    var done: Boolean,
    var text: String?
)  {
    // ...
}
</code></pre>
<p>Optional fields can also be set to a default <code>null</code> value:</p>
<pre><code class="language-idl">dictionary TodoEntry {
    boolean done;
    string? text = null;
};
</code></pre>
<p>The corresponding generated Kotlin code would be equivalent to:</p>
<pre><code class="language-kotlin">data class TodoEntry (
    var done: Boolean,
    var text: String? = null
)  {
    // ...
}
</code></pre>
<p>This works for Swift and Python targets too.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="functions"><a class="header" href="#functions">Functions</a></h1>
<p>All top-level <em>functions</em> get exposed through the UDL's <code>namespace</code> block.
For example, if the crate's <code>lib.rs</code> file contains:</p>
<pre><code class="language-rust">fn hello_world() -&gt; String {
    &quot;Hello World!&quot;.to_owned()
}</code></pre>
<p>The UDL file will look like:</p>
<pre><code class="language-idl">namespace Example {
    string hello_world();
}
</code></pre>
<h2 id="optional-arguments--default-values"><a class="header" href="#optional-arguments--default-values">Optional arguments &amp; default values</a></h2>
<p>Function arguments can be marked <code>optional</code> with a default value specified.</p>
<p>In the UDL file:</p>
<pre><code class="language-idl">namespace Example {
    string hello_name(optional string name = &quot;world&quot;);
}
</code></pre>
<p>The Rust code will take a required argument:</p>
<pre><code class="language-rust">fn hello_name(name: String) -&gt; String {
    format!(&quot;Hello {}&quot;, name)
}</code></pre>
<p>The generated foreign-language bindings will use function parameters with default values.
This works for the Kotlin, Swift and Python targets.</p>
<p>For example the generated Kotlin code will be equivalent to:</p>
<pre><code class="language-kotlin">fun helloName(name: String = &quot;world&quot; ): String {
    // ...
}
</code></pre>
<h2 id="async"><a class="header" href="#async">Async</a></h2>
<p>Async functions can be exposed using the <code>[Async]</code> attribute:</p>
<pre><code class="language-idl">namespace Example {
    [Async]
    string async_hello();
}
</code></pre>
<p>See the <a href="udl/../futures.html">Async/Future support section</a> for details.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="throwing-errors"><a class="header" href="#throwing-errors">Throwing errors</a></h1>
<p>It is often the case that a function does not return <code>T</code> in Rust but <code>Result&lt;T, E&gt;</code> to reflect that it is fallible.<br />
For UniFFI to expose this error, your error type (<code>E</code>) must be an <code>enum</code> and implement <code>std::error::Error</code> (<a href="https://crates.io/crates/thiserror">thiserror</a> works!).</p>
<p>Here's how you would write a Rust failible function and how you'd expose it in UDL:</p>
<pre><code class="language-rust">#[derive(Debug, thiserror::Error)]
enum ArithmeticError {
    #[error(&quot;Integer overflow on an operation with {a} and {b}&quot;)]
    IntegerOverflow { a: u64, b: u64 },
}

fn add(a: u64, b: u64) -&gt; Result&lt;u64, ArithmeticError&gt; {
    a.checked_add(b).ok_or(ArithmeticError::IntegerOverflow { a, b })
}</code></pre>
<p>And in UDL:</p>
<pre><code>[Error]
enum ArithmeticError {
  &quot;IntegerOverflow&quot;,
};


namespace arithmetic {
  [Throws=ArithmeticError]
  u64 add(u64 a, u64 b);
}
</code></pre>
<p>On the other side (Kotlin, Swift etc.), a proper exception will be thrown if <code>Result::is_err()</code> is <code>true</code>.</p>
<p>If you want to expose the associated data as fields on the exception, use this syntax:</p>
<pre><code>[Error]
interface ArithmeticError {
  IntegerOverflow(u64 a, u64 b);
};
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="interfacesobjects"><a class="header" href="#interfacesobjects">Interfaces/Objects</a></h1>
<p>Interfaces are represented in the Rust world as a struct with an <code>impl</code> block containing methods. In the Kotlin or Swift world, it's a class.</p>
<p>Because Objects are passed by reference and Dictionaries by value, in the UniFFI world it is impossible to be both an Object and a <a href="udl/./structs.html">Dictionary</a>.</p>
<p>The following Rust code:</p>
<pre><code class="language-rust">struct TodoList {
    items: RwLock&lt;Vec&lt;String&gt;&gt;
}

impl TodoList {
    fn new() -&gt; Self {
        TodoList {
            items: RwLock::new(Vec::new())
        }
    }

    fn add_item(&amp;self, todo: String) {
        self.items.write().unwrap().push(todo);
    }

    fn get_items(&amp;self) -&gt; Vec&lt;String&gt; {
        self.items.read().unwrap().clone()
    }
}</code></pre>
<p>would be exposed using:</p>
<pre><code class="language-idl">interface TodoList {
    constructor();
    void add_item(string todo);
    sequence&lt;string&gt; get_items();
};
</code></pre>
<p>By convention, the <code>constructor()</code> calls the Rust's <code>new()</code> method.</p>
<p>Conceptually, these <code>interface</code> objects are live Rust structs that have a proxy object on the foreign language side; calling any methods on them, including a constructor or destructor results in the corresponding methods being called in Rust. If you do not specify a constructor the bindings will be unable to create the interface directly.</p>
<p>UniFFI will generate these proxies with an interface or protocol to help with testing in the foreign-language code. For example in Kotlin, the <code>TodoList</code> would generate:</p>
<pre><code class="language-kotlin">interface TodoListInterface {
    fun addItem(todo: String)
    fun getItems(): List&lt;String&gt;
}

class TodoList : TodoListInterface {
   // implementations to call the Rust code.
}
</code></pre>
<p>When working with these objects, it may be helpful to always pass the interface or protocol, but construct the concrete implementation. For example in Swift:</p>
<pre><code class="language-swift">let todoList = TodoList()
todoList.addItem(todo: &quot;Write documentation&quot;)
display(list: todoList)

func display(list: TodoListProtocol) {
    let items = list.getItems()
    items.forEach {
        print($0)
    }
}
</code></pre>
<p>Following this pattern will make it easier for you to provide mock implementation of the Rust-based objects
for testing.</p>
<h2 id="exposing-traits-as-interfaces"><a class="header" href="#exposing-traits-as-interfaces">Exposing Traits as interfaces</a></h2>
<p>It's possible to have UniFFI expose a Rust trait as an interface by specifying a <code>Trait</code> attribute.</p>
<p>For example, in the UDL file you might specify:</p>
<pre><code class="language-idl">[Trait]
interface Button {
    string name();
};

</code></pre>
<p>With the following Rust implementation:</p>
<pre><code class="language-rust">pub trait Button: Send + Sync {
    fn name(&amp;self) -&gt; String;
}

struct StopButton {}

impl Button for StopButton  {
    fn name(&amp;self) -&gt; String {
        &quot;stop&quot;.to_string()
    }
}</code></pre>
<p>Uniffi explicitly checks all interfaces are <code>Send + Sync</code> - there's a ui-test which demonstrates obscure rust compiler errors when it's not true. Traits however need to explicitly add those bindings.</p>
<p>References to traits are passed around like normal interface objects - in an <code>Arc&lt;&gt;</code>.
For example, this UDL:</p>
<pre><code class="language-idl">namespace traits {
    sequence&lt;Button&gt; get_buttons();
    Button press(Button button);
};
</code></pre>
<p>would have these signatures in Rust:</p>
<pre><code class="language-rust">fn get_buttons() -&gt; Vec&lt;Arc&lt;dyn Button&gt;&gt; { ... }
fn press(button: Arc&lt;dyn Button&gt;) -&gt; Arc&lt;dyn Button&gt; { ... }</code></pre>
<h3 id="foreign-implementations"><a class="header" href="#foreign-implementations">Foreign implementations</a></h3>
<p>Use the <code>WithForeign</code> attribute to allow traits to also be implemented on the foreign side passed into Rust, for example:</p>
<pre><code class="language-idl">[Trait, WithForeign]
interface Button {
    string name();
};
</code></pre>
<pre><code class="language-python">class PyButton(uniffi_module.Button):
    def name(self):
        return &quot;PyButton&quot;

uniffi_module.press(PyButton())
</code></pre>
<p>Note: This is currently only supported on Python, Kotlin, and Swift.</p>
<h3 id="traits-construction"><a class="header" href="#traits-construction">Traits construction</a></h3>
<p>Because any number of <code>struct</code>s may implement a trait, they don't have constructors.</p>
<h3 id="traits-example"><a class="header" href="#traits-example">Traits example</a></h3>
<p>See the <a href="https://github.com/mozilla/uniffi-rs/tree/main/examples/traits">&quot;traits&quot; example</a> for more.</p>
<h2 id="alternate-named-constructors"><a class="header" href="#alternate-named-constructors">Alternate Named Constructors</a></h2>
<p>In addition to the default constructor connected to the <code>::new()</code> method, you can specify
alternate named constructors to create object instances in different ways. Each such constructor
must be given an explicit name, provided in the UDL with the <code>[Name]</code> attribute like so:</p>
<pre><code class="language-idl">interface TodoList {
    // The default constructor makes an empty list.
    constructor();
    // This alternate constructor makes a new TodoList from a list of string items.
    [Name=new_from_items]
    constructor(sequence&lt;string&gt; items);
    ...
</code></pre>
<p>For each alternate constructor, UniFFI will expose an appropriate static-method, class-method or similar
in the foreign language binding, and will connect it to the Rust method of the same name on the underlying
Rust struct.</p>
<h2 id="exposing-methods-from-standard-rust-traits"><a class="header" href="#exposing-methods-from-standard-rust-traits">Exposing methods from standard Rust traits</a></h2>
<p>Rust has a number of general purpose traits which add functionality to objects, such
as <code>Debug</code>, <code>Display</code>, etc. It's possible to tell UniFFI that your object implements these
traits and to generate FFI functions to expose them to consumers. Bindings may then optionally
generate special methods on the object.</p>
<p>For example, consider the following example:</p>
<pre><code>[Traits=(Debug)]
interface TodoList {
    ...
}
</code></pre>
<p>and the following Rust code:</p>
<pre><code class="language-rust">#[derive(Debug)]
struct TodoList {
   ...
}</code></pre>
<p>(or using proc-macros)</p>
<pre><code class="language-rust">#[derive(Debug, uniffi::Object)]
#[uniffi::export(Debug)]
struct TodoList {
   ...
}</code></pre>
<p>This will cause the Python bindings to generate a <code>__repr__</code> method that returns the value implemented by the <code>Debug</code> trait.
Not all bindings support generating special methods, so they may be ignored.
It is your responsibility to implement the trait on your objects; UniFFI will attempt to generate a meaningful error if you do not.</p>
<p>The list of supported traits is hard-coded in UniFFI's internals, and at time of writing
is <code>Debug</code>, <code>Display</code>, <code>Eq</code> and <code>Hash</code>.</p>
<h2 id="managing-shared-references"><a class="header" href="#managing-shared-references">Managing Shared References</a></h2>
<p>To the foreign-language consumer, UniFFI object instances are designed to behave as much like
regular language objects as possible. They can be freely passed as arguments or returned as values,
like this:</p>
<pre><code class="language-idl">interface TodoList {
    ...

    // Copy the items from another TodoList into this one.
    void import_items(TodoList other);

    // Make a copy of this TodoList as a new instance.
    TodoList duplicate();

    // Create a list of lists, one for each item this one
    sequence&lt;TodoList&gt; split();
};
</code></pre>
<p>To ensure that this is safe, UniFFI allocates every object instance on the heap using
<a href="https://doc.rust-lang.org/std/sync/struct.Arc.html"><code>Arc</code></a>, Rust's built-in smart pointer
type for managing shared references at runtime.</p>
<p>The use of <code>Arc</code> is transparent to the foreign-language code, but sometimes shows up
in the function signatures of the underlying Rust code.</p>
<p>When returning interface objects, UniFFI supports both Rust functions that wrap the value in an
<code>Arc&lt;&gt;</code> and ones that don't.  This only applies if the interface type is returned directly:</p>
<pre><code class="language-rust">impl TodoList {
    // When the foreign function/method returns `TodoList`, the Rust code can return either `TodoList` or `Arc&lt;TodoList&gt;`.
    fn duplicate(&amp;self) -&gt; TodoList {
        TodoList {
            items: RwLock::new(self.items.read().unwrap().clone())
        }
    }

    // However, if TodoList is nested inside another type then `Arc&lt;TodoList&gt;` is required
    fn split(&amp;self) -&gt; Vec&lt;Arc&lt;TodoList&gt;&gt; {
        self.items.read()
            .iter()
            .map(|i| Arc::new(TodoList::from_item(i.clone()))
            .collect()
    }
}</code></pre>
<p>By default, object instances passed as function arguments will also be passed as an <code>Arc&lt;T&gt;</code>, so the
Rust implementation of <code>TodoList::import_items</code> would also need to accept an <code>Arc&lt;TodoList&gt;</code>:</p>
<pre><code class="language-rust">impl TodoList {
    fn import_items(&amp;self, other: Arc&lt;TodoList&gt;) {
        self.items.write().unwrap().append(other.get_items());
    }
}</code></pre>
<p>If the Rust code does not need an owned reference to the <code>Arc</code>, you can use the <code>[ByRef]</code> UDL attribute
to signal that a function accepts a borrowed reference:</p>
<pre><code class="language-idl">interface TodoList {
    ...
    //                  +-- indicate that we only need to borrow the other list
    //                  V
    void import_items([ByRef] TodoList other);
    ...
};
</code></pre>
<pre><code class="language-rust">impl TodoList {
    //                              +-- don't need to care about the `Arc` here
    //                              V
    fn import_items(&amp;self, other: &amp;TodoList) {
        self.items.write().unwrap().append(other.get_items());
    }
}</code></pre>
<p>Conversely, if the Rust code explicitly <em>wants</em> to deal with an <code>Arc&lt;T&gt;</code> in the special case of
the <code>self</code> parameter, it can signal this using the <code>[Self=ByArc]</code> UDL attribute on the method:</p>
<pre><code class="language-idl">interface TodoList {
    ...
    // +-- indicate that we want the `Arc` containing `self`
    // V
    [Self=ByArc]
    void import_items(TodoList other);
    ...
};
</code></pre>
<pre><code class="language-rust">impl TodoList {
    // `Arc`s everywhere! --+-----------------+
    //                      V                 V
    fn import_items(self: Arc&lt;Self&gt;, other: Arc&lt;TodoList&gt;) {
        self.items.write().unwrap().append(other.get_items());
    }
}</code></pre>
<p>You can read more about the technical details in the docs on the
<a href="udl/../internals/object_references.html">internal details of managing object references</a>.</p>
<h2 id="concurrent-access"><a class="header" href="#concurrent-access">Concurrent Access</a></h2>
<p>Since interfaces represent mutable data, UniFFI has to take extra care
to uphold Rust's safety guarantees around shared and mutable references.
The foreign-language code may attempt to operate on an interface instance
from multiple threads, and it's important that this not violate Rust's
assumption that there is at most a single mutable reference to a struct
at any point in time.</p>
<p>UniFFI enforces this by requiring that the Rust implementation of an interface
be <code>Sync+Send</code>, and you will get a compile-time error if your implementation
does not satisfy this requirement. For example, consider a small &quot;counter&quot;
object declared like so:</p>
<pre><code class="language-idl">interface Counter {
    constructor();
    void increment();
    u64 get();
};
</code></pre>
<p>For this to be safe, the underlying Rust struct must adhere to certain restrictions, and
UniFFI's generated Rust scaffolding will emit compile-time errors if it does not.</p>
<p>The Rust struct must not expose any methods that take <code>&amp;mut self</code>. The following implementation
of the <code>Counter</code> interface will fail to compile because it relies on mutable references:</p>
<pre><code class="language-rust">struct Counter {
    value: u64
}

impl Counter {
    fn new() -&gt; Self {
        Self { value: 0 }
    }

    // No mutable references to self allowed in UniFFI interfaces.
    fn increment(&amp;mut self) {
        self.value = self.value + 1;
    }

    fn get(&amp;self) -&gt; u64 {
        self.value
    }
}</code></pre>
<p>Implementations can instead use Rust's &quot;interior mutability&quot; pattern. However, they
must do so in a way that is both <code>Sync</code> and <code>Send</code>, since the foreign-language code
may operate on the instance from multiple threads. The following implementation of the
<code>Counter</code> interface will fail to compile because <code>RefCell</code> is not <code>Sync</code>:</p>
<pre><code class="language-rust">struct Counter {
    value: RefCell&lt;u64&gt;
}

impl Counter {
    fn new() -&gt; Self {
        // `RefCell` is not `Sync`, so neither is `Counter`.
        Self { value: RefCell::new(0) }
    }

    fn increment(&amp;self) {
        let mut value = self.value.borrow_mut();
        *value = *value + 1;
    }

    fn get(&amp;self) -&gt; u64 {
        *self.value.borrow()
    }
}</code></pre>
<p>This version uses an <code>AtomicU64</code> for interior mutability, which is both <code>Sync</code> and
<code>Send</code> and hence will compile successfully:</p>
<pre><code class="language-rust">struct Counter {
    value: AtomicU64
}

impl Counter {
    fn new() -&gt; Self {
        Self { value: AtomicU64::new(0) }
    }

    fn increment(&amp;self) {
        self.value.fetch_add(1, Ordering::SeqCst);
    }

    fn get(&amp;self) -&gt; u64 {
        self.value.load(Ordering::SeqCst)
    }
}</code></pre>
<p>You can read more about the technical details in the docs on the
<a href="udl/../internals/object_references.html">internal details of managing object references</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="callback-interfaces"><a class="header" href="#callback-interfaces">Callback interfaces</a></h1>
<p>Callback interfaces are a special implementation of
<a href="udl/../foreign_traits.html">Rust traits implemented by foreign languages</a>.</p>
<p>These are described in both UDL and proc-macros as an explicit &quot;callback interface&quot;.
They are (soft) deprecated, remain now for backwards compatibility, but probably
should be avoided.</p>
<p>This document describes the differences from regular traits.</p>
<h2 id="defining-a-callback"><a class="header" href="#defining-a-callback">Defining a callback</a></h2>
<p>If you must define a callback in UDL it would look like:</p>
<pre><code class="language-webidl">callback interface Keychain {
  // as described in the foreign traits docs...
};
</code></pre>
<p>procmacros support it too, but just don't use it :)</p>
<h3 id="box-and-send--sync"><a class="header" href="#box-and-send--sync">Box and Send + Sync?</a></h3>
<p>Traits defined purely for callbacks probably don't technically need to be <code>Sync</code> in Rust, but
they conceptually are, just outside of Rust's view.</p>
<p>That is, the methods of the foreign class must be safe to call
from multiple threads at once, but Rust can not enforce this in the foreign code.</p>
<h2 id="rust-signature-differences"><a class="header" href="#rust-signature-differences">Rust signature differences</a></h2>
<p>Consider the examples in <a href="udl/../foreign_traits.html">Rust traits implemented by foreign languages</a>.</p>
<p>If the traits in question are defined as a &quot;callback&quot; interface, the <code>Arc&lt;dyn Keychain&gt;</code> types
would actually be <code>Box&lt;dyn Keychain&gt;</code> - eg, the Rust implementation of the <code>Authenticator</code>
constructor would be <code>fn new(keychain: Box&lt;dyn Keychain&gt;) -&gt; Self</code> instead of the <code>Arc&lt;&gt;</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="external-types"><a class="header" href="#external-types">External types</a></h1>
<p>External types are types implemented by UniFFI but outside of this UDL file.</p>
<p>They are similar to, but different from <a href="udl/./custom_types.html">custom types</a> which wrap UniFFI primitive types.</p>
<p>But like custom types, external types are all declared using a <code>typedef</code> with attributes
giving more detail.</p>
<h2 id="types-in-another-crate"><a class="header" href="#types-in-another-crate">Types in another crate</a></h2>
<p><a href="udl/./ext_types_external.html">There's a whole page about that!</a></p>
<h2 id="types-from-procmacros-in-this-crate"><a class="header" href="#types-from-procmacros-in-this-crate">Types from procmacros in this crate.</a></h2>
<p>If your crate has types defined via <code>#[uniffi::export]</code> etc you can make them available
to the UDL file in your own crate via a <code>typedef</code> with a <code>[Rust=]</code> attribute. Eg, your Rust
might have:</p>
<pre><code class="language-rust">#[derive(uniffi::Record)]
pub struct One {
    inner: i32,
}</code></pre>
<p>you can use it in your UDL:</p>
<pre><code class="language-idl">[Rust=&quot;record&quot;]
typedef extern One;

namespace app {
    // use the procmacro type.
    One get_one(One? one);
}

</code></pre>
<p>Supported values:</p>
<ul>
<li>&quot;enum&quot;, &quot;trait&quot;, &quot;callback&quot;, &quot;trait_with_foreign&quot;</li>
<li>For records, either &quot;record&quot; or &quot;dictionary&quot;</li>
<li>For objects, either &quot;object&quot; or &quot;interface&quot;</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="declaring-external-types"><a class="header" href="#declaring-external-types">Declaring External Types</a></h1>
<p>It is possible to use types defined by UniFFI in an external crate. For example, let's assume
that you have an existing crate named <code>demo_crate</code> with the following UDL:</p>
<pre><code class="language-idl">dictionary DemoDict {
  string string_val;
  boolean bool_val;
};
</code></pre>
<p>Inside another crate, <code>consuming_crate</code>, you'd like to use this dictionary.
Inside <code>consuming_crate</code>'s UDL file you can reference <code>DemoDict</code> by using a
<code>typedef</code> with an <code>External</code> attribute, as shown below.</p>
<pre><code class="language-idl">[External=&quot;demo_crate&quot;]
typedef extern DemoDict;

// Now define our own dictionary which references the imported type.
dictionary ConsumingDict {
  DemoDict demo_dict;
  boolean another_bool;
};

</code></pre>
<p>Inside <code>consuming_crate</code>'s Rust code you must <code>use</code> that struct as normal - for example,
<code>consuming_crate</code>'s <code>lib.rs</code> might look like:</p>
<pre><code class="language-rust">use demo_crate::DemoDict;

pub struct ConsumingDict {
    demo_dict: DemoDict,
    another_bool: bool,
}

uniffi::include_scaffolding!(&quot;consuming_crate&quot;);</code></pre>
<p>Your <code>Cargo.toml</code> must reference the external crate as normal.</p>
<p>The <code>External</code> attribute can be specified on dictionaries, enums, errors.</p>
<h2 id="external-interface-and-trait-types"><a class="header" href="#external-interface-and-trait-types">External interface and trait types</a></h2>
<p>If the external type is an <a href="udl/./interfaces.html">Interface</a>, then use the <code>[ExternalInterface]</code> attribute instead of <code>[External]</code>:</p>
<pre><code class="language-idl">[ExternalInterface=&quot;demo_crate&quot;]
typedef extern DemoInterface;
</code></pre>
<p>similarly for traits: use <code>[ExternalTrait]</code>.</p>
<h2 id="external-procmacro-types"><a class="header" href="#external-procmacro-types">External procmacro types</a></h2>
<p>The above examples assume the external types were defined via UDL.
If they were defined by procmacros, you need different attribute names:</p>
<ul>
<li>if <code>DemoDict</code> is implemented by a procmacro in <code>demo_crate</code>, you'd use <code>[ExternalExport=...]</code></li>
<li>for <code>DemoInterface</code> you'd use <code>[ExternalInterfaceExport=...]</code></li>
</ul>
<p>For types defined by procmacros in <em>this</em> crate, see the <a href="udl/./ext_types.html">attribute <code>[Rust=...]</code></a></p>
<h2 id="foreign-bindings"><a class="header" href="#foreign-bindings">Foreign bindings</a></h2>
<p>The foreign bindings will also need to know how to access the external type,
which varies slightly for each language:</p>
<h3 id="kotlin-1"><a class="header" href="#kotlin-1">Kotlin</a></h3>
<p>For Kotlin, &quot;library mode&quot; generation with <code>generate --library [path-to-cdylib]</code> is recommended when using external types.
If you use <code>generate [udl-path]</code> then the generated code needs to know how to import
the external types from the Kotlin module that corresponds to the Rust crate.
By default, UniFFI assumes that the Kotlin module name matches the Rust crate name, but this can be configured in <code>uniffi.toml</code> with an entry like this:</p>
<pre><code>[bindings.kotlin.external_packages]
# Map the crate names from [External={name}] into Kotlin package names
rust-crate-name = &quot;kotlin.package.name&quot;
</code></pre>
<h3 id="swift-1"><a class="header" href="#swift-1">Swift</a></h3>
<p>For Swift, you must compile all generated <code>.swift</code> files together in a single
module since the generate code expects that it can access external types
without importing them.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="custom-types"><a class="header" href="#custom-types">Custom types</a></h1>
<p>Custom types allow you to extend the UniFFI type system to support types from your Rust crate or 3rd
party libraries.  This relies on a <a href="udl/./builtin_types.html">builtin</a> UDL type move data across the
FFI, followed by a conversion to your custom type.</p>
<h2 id="custom-types-in-the-scaffolding-code"><a class="header" href="#custom-types-in-the-scaffolding-code">Custom types in the scaffolding code</a></h2>
<p>Consider the following trivial Rust abstraction for a &quot;handle&quot; which wraps an integer:</p>
<pre><code class="language-rust">pub struct Handle(i64);</code></pre>
<p>You can use this type in your udl by declaring it via a <code>typedef</code> with a <code>Custom</code> attribute,
defining the builtin type that it's based on.</p>
<pre><code class="language-idl">[Custom]
typedef i64 Handle;
</code></pre>
<p>For this to work, your Rust code must also implement a special trait named
<code>UniffiCustomTypeConverter</code>. This trait is generated by UniFFI and can be found in the generated
Rust scaffolding - it is defined as:</p>
<pre><code class="language-Rust">trait UniffiCustomTypeConverter {
    type Builtin;

    fn into_custom(val: Self::Builtin) -&gt; uniffi::Result&lt;Self&gt;
    where
        Self: Sized;
    fn from_custom(obj: Self) -&gt; Self::Builtin;
}
</code></pre>
<p>where <code>Builtin</code> is the Rust type corresponding to the UniFFI builtin-type - <code>i64</code> in the example above. Thus, the trait
implementation for <code>Handle</code> would look something like:</p>
<pre><code class="language-rust">impl UniffiCustomTypeConverter for Handle {
    type Builtin = i64;

    fn into_custom(val: Self::Builtin) -&gt; uniffi::Result&lt;Self&gt; {
        Ok(Handle(val))
    }

    fn from_custom(obj: Self) -&gt; Self::Builtin {
        obj.0
    }
}</code></pre>
<p>Because <code>UniffiCustomTypeConverter</code> is defined in each crate, this means you can use custom types even
if they are not defined in your crate - see the 'custom_types' example which demonstrates
<code>url::Url</code> as a custom type.</p>
<h2 id="error-handling-during-conversion"><a class="header" href="#error-handling-during-conversion">Error handling during conversion</a></h2>
<p>You might have noticed that the <code>into_custom</code> function returns a <code>uniffi::Result&lt;Self&gt;</code> (which is an
alias for <code>anyhow::Result</code>) and might be wondering what happens if you return an <code>Err</code>.</p>
<p>It depends on the context. In short:</p>
<ul>
<li>
<p>If the value is being used as an argument to a function/constructor that does not return
a <code>Result</code> (ie, does not have the <code>throws</code> attribute in the .udl), then the uniffi generated
scaffolding code will <code>panic!()</code></p>
</li>
<li>
<p>If the value is being used as an argument to a function/constructor that <em>does</em> return a
<code>Result</code> (ie, does have a <code>throws</code> attribute in the .udl), then the uniffi generated
scaffolding code will use <code>anyhow::Error::downcast()</code> to try and convert the failure into
that declared error type and:</p>
<ul>
<li>If that conversion succeeds, it will be used as the <code>Err</code> for the function.</li>
<li>If that conversion fails, it will <code>panic()</code></li>
</ul>
</li>
</ul>
<h3 id="example"><a class="header" href="#example">Example</a></h3>
<p>For example, consider the following UDL:</p>
<pre><code class="language-idl">[Custom]
typedef i64 Handle;

[Error]
enum ExampleError {
    &quot;InvalidHandle&quot;
};

namespace errors_example {
    take_handle_1(Handle handle);

    [Throws=ExampleError]
    take_handle_2(Handle handle);
}
</code></pre>
<p>and the following Rust:</p>
<pre><code class="language-rust">#[derive(Debug, thiserror::Error)]
pub enum ExampleError {
    #[error(&quot;The handle is invalid&quot;)]
    InvalidHandle,
}

impl UniffiCustomTypeConverter for ExampleHandle {
    type Builtin = i64;

    fn into_custom(val: Self::Builtin) -&gt; uniffi::Result&lt;Self&gt; {
        if val == 0 {
            Err(ExampleErrors::InvalidHandle.into())
        } else if val == -1 {
            Err(SomeOtherError.into()) // SomeOtherError decl. not shown.
        } else {
            Ok(Handle(val))
        }
    }
    // ...
}</code></pre>
<p>The behavior of the generated scaffolding will be:</p>
<ul>
<li>Calling <code>take_handle_1</code> with a value of <code>0</code> or <code>-1</code> will always panic.</li>
<li>Calling <code>take_handle_2</code> with a value of <code>0</code> will throw an <code>ExampleError</code> exception</li>
<li>Calling <code>take_handle_2</code> with a value of <code>-1</code> will always panic.</li>
<li>All other values will return <code>Ok(ExampleHandle)</code></li>
</ul>
<h2 id="custom-types-in-the-bindings-code"><a class="header" href="#custom-types-in-the-bindings-code">Custom types in the bindings code</a></h2>
<p><em>Note: The facility described in this document is not yet available for the Ruby bindings.</em></p>
<p>By default, the foreign bindings just see the builtin type - eg, the bindings will get an integer
for the <code>Handle</code>.</p>
<p>However, custom types can also be converted on the bindings side.  For example, a Url type could be
configured to use the <code>java.net.URL</code> class in Kotlin by adding code like this to <code>uniffi.toml</code>:</p>
<pre><code class="language-toml">[bindings.kotlin.custom_types.Url]
# Name of the type in the Kotlin code
type_name = &quot;URL&quot;
# Classes that need to be imported
imports = [ &quot;java.net.URL&quot; ]
# Expression to convert the builtin type the custom type.  In this example, `{}` will be replaced with the int value.
into_custom = &quot;URL({})&quot;
# Expression to convert the custom type to the builtin type.  In this example, `{}` will be replaced with the URL value.
from_custom = &quot;{}.toString()&quot;
</code></pre>
<p>Here's how the configuration works in <code>uniffi.toml</code>.</p>
<ul>
<li>Create a <code>[bindings.{language}.custom_types.{CustomTypeName}]</code> table to enable a custom type on a bindings side.  This has several subkeys:
<ul>
<li><code>type_name</code> (Optional, Typed languages only): Type/class name for the
custom type.  Defaults to the type name used in the UDL.  Note: The UDL
type name will still be used in generated function signatures, however it
will be defined as a typealias to this type.</li>
<li><code>into_custom</code>: Expression to convert the UDL type to the custom type.  <code>{}</code> will be replaced with the value of the UDL type.</li>
<li><code>from_custom</code>: Expression to convert the custom type to the UDL type.  <code>{}</code> will be replaced with the value of the custom type.</li>
<li><code>imports</code> (Optional) list of modules to import for your <code>into_custom</code>/<code>from_custom</code> functions.</li>
</ul>
</li>
</ul>
<h2 id="using-custom-types-from-other-crates"><a class="header" href="#using-custom-types-from-other-crates">Using Custom Types from other crates</a></h2>
<p>To use the <code>Handle</code> example above from another crate, these other crates just refer to the type
as a regular <code>External</code> type - for example, another crate might use <code>udl</code> such as:</p>
<pre><code class="language-idl">[External=&quot;crate_defining_handle_name&quot;]
typedef extern Handle;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="docstrings"><a class="header" href="#docstrings">Docstrings</a></h1>
<p>UDL file supports docstring comments. The comments are emitted in generated bindings without any
transformations. What you see in UDL is what you get in generated bindings. The only change made to
UDL comments are the comment syntax specific to each language. Docstrings can be used for most
declarations in UDL file. Docstrings are parsed as AST nodes, so incorrectly placed docstrings will
generate parse errors. Docstrings in UDL are comments prefixed with <code>///</code>.</p>
<h2 id="docstrings-in-udl"><a class="header" href="#docstrings-in-udl">Docstrings in UDL</a></h2>
<pre><code class="language-java">/// The list of supported capitalization options
enum Capitalization {
    /// Lowercase, i.e. `hello, world!`
    Lower,

    /// Uppercase, i.e. `Hello, World!`
    Upper
};

namespace example {
    /// Return a greeting message, using `capitalization` for capitalization
    string hello_world(Capitalization capitalization);
}
</code></pre>
<h2 id="docstrings-in-generated-kotlin-bindings"><a class="header" href="#docstrings-in-generated-kotlin-bindings">Docstrings in generated Kotlin bindings</a></h2>
<pre><code class="language-kotlin">/**
 * The list of supported capitalization options
 */
enum class Capitalization {
    /**
     * Lowercase, i.e. `hello, world!`
     */
    LOWER,

    /**
     * Uppercase, i.e. `Hello, World!`
     */
    UPPER;
}

/**
 * Return a greeting message, using `capitalization` for capitalization
 */
fun `helloWorld`(`capitalization`: Capitalization): String { .. }
</code></pre>
<h2 id="docstrings-in-generated-swift-bindings"><a class="header" href="#docstrings-in-generated-swift-bindings">Docstrings in generated Swift bindings</a></h2>
<pre><code class="language-swift">/**
 * The list of supported capitalization options
 */
public enum Capitalization {
    /**
     * Lowercase, i.e. `hello, world!`
     */
    case lower

    /**
     * Uppercase, i.e. `Hello, World!`
     */
    case upper
}

/**
 * Return a greeting message, using `capitalization` for capitalization
 */
public func helloWorld(capitalization: Capitalization) -&gt; String;
</code></pre>
<h2 id="docstrings-in-generated-python-bindings"><a class="header" href="#docstrings-in-generated-python-bindings">Docstrings in generated Python bindings</a></h2>
<pre><code class="language-python">class Capitalization(enum.Enum):
    &quot;&quot;&quot;The list of supported capitalization options&quot;&quot;&quot;

    LOWER = 1
    &quot;&quot;&quot;Lowercase, i.e. `hello, world!`&quot;&quot;&quot;

    UPPER = 2
    &quot;&quot;&quot;Uppercase, i.e. `Hello, World!`&quot;&quot;&quot;

def hello_world(capitalization: &quot;Capitalization&quot;) -&gt; &quot;str&quot;:
    &quot;&quot;&quot;Return a greeting message, using `capitalization` for capitalization&quot;&quot;&quot;
    ..
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="procedural-macros-attributes-and-derives"><a class="header" href="#procedural-macros-attributes-and-derives">Procedural Macros: Attributes and Derives</a></h1>
<p>UniFFI allows you to define your function signatures and type definitions directly in your Rust
code, avoiding the need to duplicate them in a UDL file and so avoiding the possibility for the two to get out of sync.
This  mechanism is based on <a href="https://doc.rust-lang.org/reference/procedural-macros.html">Procedural Macros</a> (proc-macros), specifically the attribute and derive macros.</p>
<p>You can have this mechanism extract some kinds of definitions out of your Rust code,
in addition to what is declared in the UDL file. However, you have to make sure
that the UDL file is still valid on its own: All types referenced in fields, parameter and return
types in UDL must also be declared in UDL.</p>
<p>Further, using this capability probably means you still need to refer to the UDL documentation,
because at this time, that documentation tends to conflate the UniFFI type model and the
description of how foreign bindings use that type model. For example, the documentation for
a UDL interface describes both how it is defined in UDL and how Swift and Kotlin might use
that interface. The latter is relevant even if you define the interface using proc-macros
instead of in UDL.</p>
<p><strong>⚠ Warning ⚠</strong> This facility is relatively new, so things may change often. However, this remains
true for all of UniFFI, so proceed with caution and the knowledge that things may break in the future.</p>
<h2 id="build-workflow"><a class="header" href="#build-workflow">Build workflow</a></h2>
<p>Be sure to use library mode when using UniFFI proc-macros (See the <a href="proc_macro/../tutorial/foreign_language_bindings.html">Foreign language bindings docs</a> for more info).</p>
<p>If your crate's API is declared using only proc-macros and not UDL files, call the <code>uniffi::setup_scaffolding</code> macro at the top of your source code:</p>
<pre><code class="language-rust">uniffi::setup_scaffolding!();</code></pre>
<p><strong>⚠ Warning ⚠</strong> Do not call both <code>uniffi::setup_scaffolding!()</code> and <code>uniffi::include_scaffolding!!()</code> in the same crate.</p>
<h2 id="the-uniffiexport-attribute"><a class="header" href="#the-uniffiexport-attribute">The <code>#[uniffi::export]</code> attribute</a></h2>
<p>The most important proc-macro is the <code>export</code> attribute. It can be used on functions, <code>impl</code>
blocks, and <code>trait</code> definitions to make UniFFI aware of them.</p>
<pre><code class="language-rust">#[uniffi::export]
fn hello_ffi() {
    println!(&quot;Hello from Rust!&quot;);
}

// Corresponding UDL:
//
// interface MyObject {};
#[derive(uniffi::Object)] 
struct MyObject {
    // ...
}

#[uniffi::export]
impl MyObject {
    // Constructors need to be annotated as such.
    // The return value can be either `Self` or `Arc&lt;Self&gt;`
    // It is treated as the primary constructor, so in most languages this is invoked with
    `MyObject()`.
    #[uniffi::constructor]
    fn new(argument: String) -&gt; Arc&lt;Self&gt; {
        // ...
    }

    // Constructors with different names are also supported, usually invoked
    // as `MyObject.named()` (depending on the target language)
    #[uniffi::constructor]
    fn named() -&gt; Arc&lt;Self&gt; {
        // ...
    }

    // All functions that are not constructors must have a `self` argument
    fn method_a(&amp;self) {
        // ...
    }

    // Returning objects is also supported, either as `Self` or `Arc&lt;Self&gt;`
    fn method_b(self: Arc&lt;Self&gt;) {
        // ...
    }
}

// Corresponding UDL:
// [Trait]
// interface MyTrait {};
#[uniffi::export]
trait MyTrait {
    // ...
}

// Corresponding UDL:
// [Trait, WithForeign]
// interface MyTrait {};
#[uniffi::export(with_foreign)]
trait MyTrait {
    // ...
}</code></pre>
<p>All owned <a href="proc_macro/../udl/builtin_types.html">builtin types</a> and user-defined types can be used as arguments
and return types.</p>
<p>Arguments and receivers can also be references to these types, for example:</p>
<pre><code class="language-rust">// Input data types as references
#[uniffi::export]
fn process_data(a: &amp;MyRecord, b: &amp;MyEnum, c: Option&lt;&amp;MyRecord&gt;) {
    ...
}

#[uniffi::export]
impl Foo {
  // Methods can take a `&amp;self`, which will be borrowed from `Arc&lt;Self&gt;`
  fn some_method(&amp;self) {
    ...
  }
}

// Input foo as an Arc and bar as a reference
fn call_both(foo: Arc&lt;Foo&gt;, bar: &amp;Foo) {
  foo.some_method();
  bar.some_method();
}</code></pre>
<p>The one restriction is that the reference must be visible in the function signature.  This wouldn't
work:</p>
<pre><code class="language-rust">type MyFooRef = &amp;'static Foo;

// ERROR: UniFFI won't recognize that the `foo` argument is a reference.
#[uniffi::export]
fn do_something(foo: MyFooRef) {
}</code></pre>
<h2 id="the-uniffirecord-derive"><a class="header" href="#the-uniffirecord-derive">The <code>uniffi::Record</code> derive</a></h2>
<p>The <code>Record</code> derive macro exposes a <code>struct</code> with named fields over FFI. All types that are
supported as parameter and return types by <code>#[uniffi::export]</code> are also supported as field types
here.</p>
<p>It is permitted to use this macro on a type that is also defined in the UDL file, as long as all
field types are UniFFI builtin types; user-defined types might be allowed in the future. You also
have to maintain a consistent field order between the Rust and UDL files (otherwise compilation
will fail).</p>
<pre><code class="language-rust">#[derive(uniffi::Record)]
pub struct MyRecord {
    pub field_a: String,
    pub field_b: Option&lt;Arc&lt;MyObject&gt;&gt;,
    // Fields can have a default value.
    // Currently, only string, integer, float and boolean literals are supported as defaults.
    #[uniffi(default = &quot;hello&quot;)]
    pub greeting: String,
    #[uniffi(default = true)]
    pub some_flag: bool,
}</code></pre>
<h2 id="the-uniffienum-derive"><a class="header" href="#the-uniffienum-derive">The <code>uniffi::Enum</code> derive</a></h2>
<p>The <code>Enum</code> derive macro works much like the <code>Record</code> derive macro. Any fields inside variants must
be named. All types that are supported as parameter and return types by <code>#[uniffi::export]</code> are
also supported as field types.</p>
<p>It is permitted to use this macro on a type that is also defined in the UDL file as long as the
two definitions are equal in the names and ordering of variants and variant fields, and any field
types inside variants are UniFFI builtin types; user-defined types might be allowed in the future.</p>
<pre><code class="language-rust">#[derive(uniffi::Enum)]
pub enum MyEnum {
    Fieldless,
    WithFields {
        foo: u8,
        bar: Vec&lt;i32&gt;,
    },
    WithValue = 3,
}</code></pre>
<p>Variant discriminants are accepted by the macro but how they are used depends on the bindings.
Most would be likely ignore it in the example above due to the nature of the enum,
but some expose it for simple &quot;unit&quot; enums.</p>
<h2 id="the-uniffiobject-derive"><a class="header" href="#the-uniffiobject-derive">The <code>uniffi::Object</code> derive</a></h2>
<p>This derive can be used to replace an <code>interface</code> definition in UDL. Every object type must have
<em>either</em> an <code>interface</code> definition in UDL <em>or</em> use this derive macro. However, <code>#[uniffi::export]</code>
can be used on an impl block for an object type regardless of whether this derive is used. You can
also mix and match, and define some method of an object via proc-macro while falling back to UDL
for methods that are not supported by <code>#[uniffi::export]</code> yet; just make sure to use separate
<code>impl</code> blocks:</p>
<pre><code class="language-idl">// UDL file

interface Foo {
    void method_a();
};
</code></pre>
<pre><code class="language-rust">// Rust file

// Not deriving uniffi::Object since it is defined in UDL
struct Foo {
    // ...
}

// Implementation of the method defined in UDL
impl Foo {
    fn method_a(&amp;self) {
        // ...
    }
}

// Another impl block with an additional method
#[uniffi::export]
impl Foo {
    fn method_b(&amp;self) {
        // ...
    }
}</code></pre>
<h2 id="the-unifficustom_type-and-unifficustom_newtype-macros"><a class="header" href="#the-unifficustom_type-and-unifficustom_newtype-macros">The <code>uniffi::custom_type</code> and <code>uniffi::custom_newtype</code> macros</a></h2>
<p>There are 2 macros available which allow procmacros to support &quot;custom types&quot; as described in the
<a href="proc_macro/../udl/custom_types.html">UDL documentation for Custom Types</a></p>
<p>The <code>uniffi::custom_type!</code> macro requires you to specify the name of the custom type, and the name of the
builtin which implements this type. Use of this macro requires you to manually implement the
<code>UniffiCustomTypeConverter</code> trait for for your type, as shown below.</p>
<pre><code class="language-rust">pub struct Uuid {
    val: String,
}

// Use `Uuid` as a custom type, with `String` as the Builtin
uniffi::custom_type!(Uuid, String);

impl UniffiCustomTypeConverter for Uuid {
    type Builtin = String;

    fn into_custom(val: Self::Builtin) -&gt; uniffi::Result&lt;Self&gt; {
        Ok(Uuid { val })
    }

    fn from_custom(obj: Self) -&gt; Self::Builtin {
        obj.val
    }
}</code></pre>
<p>There's also a <code>uniffi::custom_newtype!</code> macro, designed for custom types which use the
&quot;new type&quot; idiom. You still need to specify the type name and builtin type, but because UniFFI
is able to make assumptions about how the type is laid out, <code>UniffiCustomTypeConverter</code>
is implemented automatically.</p>
<pre><code class="language-rust">uniffi::custom_newtype!(NewTypeHandle, i64);
pub struct NewtypeHandle(i64);</code></pre>
<p>and that's it!</p>
<h2 id="the-uniffierror-derive"><a class="header" href="#the-uniffierror-derive">The <code>uniffi::Error</code> derive</a></h2>
<p>The <code>Error</code> derive registers a type as an error and can be used on any enum that the <code>Enum</code> derive also accepts.
By default, it exposes any variant fields to the foreign code.
This type can then be used as the <code>E</code> in a <code>Result&lt;T, E&gt;</code> return type of an exported function or method.
The generated foreign function for an exported function with a <code>Result&lt;T, E&gt;</code> return type
will have the result's <code>T</code> as its return type and throw the error in case the Rust call returns <code>Err(e)</code>.</p>
<pre><code class="language-rust">#[derive(uniffi::Error)]
pub enum MyError {
    MissingInput,
    IndexOutOfBounds {
        index: u32,
        size: u32,
    }
    Generic {
        message: String,
    }
}

#[uniffi::export]
fn do_thing() -&gt; Result&lt;(), MyError&gt; {
    // ...
}</code></pre>
<p>You can also use the helper attribute <code>#[uniffi(flat_error)]</code> to expose just the variants but none of the fields.
In this case the error will be serialized using Rust's <code>ToString</code> trait
and will be accessible as the only field on each of the variants.
For flat errors your variants can have unnamed fields,
and the types of the fields don't need to implement any special traits.</p>
<pre><code class="language-rust">#[derive(uniffi::Error)]
#[uniffi(flat_error)]
pub enum MyApiError {
    Http(reqwest::Error),
    Json(serde_json::Error),
}

// ToString is not usually implemented directly, but you get it for free by implementing Display.
// This impl could also be generated by a proc-macro, for example thiserror::Error.
impl std::fmt::Display for MyApiError {
    // ...
}

#[uniffi::export]
fn do_http_request() -&gt; Result&lt;(), MyApiError&gt; {
    // ...
}</code></pre>
<h2 id="the-uniffiexportcallback_interface-attribute"><a class="header" href="#the-uniffiexportcallback_interface-attribute">The <code>#[uniffi::export(callback_interface)]</code> attribute</a></h2>
<p><code>#[uniffi::export(callback_interface)]</code> can be used to export a <a href="proc_macro/../udl/callback_interfaces.html">callback interface</a> definition.
This allows the foreign bindings to implement the interface and pass an instance to the Rust code.</p>
<pre><code class="language-rust">#[uniffi::export(callback_interface)]
pub trait Person {
    fn name() -&gt; String;
    fn age() -&gt; u32;
}

// Corresponding UDL:
// callback interface Person {
//     string name();
//     u32 age();
// }</code></pre>
<h2 id="types-from-dependent-crates"><a class="header" href="#types-from-dependent-crates">Types from dependent crates</a></h2>
<p>When using proc-macros, you can use types from dependent crates in your exported library, as long as
the dependent crate annotates the type with one of the UniFFI derives.  However, there are a couple
exceptions:</p>
<h3 id="types-from-udl-based-dependent-crates"><a class="header" href="#types-from-udl-based-dependent-crates">Types from UDL-based dependent crates</a></h3>
<p>If the dependent crate uses a UDL file to define their types, then you must invoke one of the
<code>uniffi::use_udl_*!</code> macros, for example:</p>
<pre><code class="language-rust">uniffi::use_udl_record!(dependent_crate, RecordType);
uniffi::use_udl_enum!(dependent_crate, EnumType);
uniffi::use_udl_error!(dependent_crate, ErrorType);
uniffi::use_udl_object!(dependent_crate, ObjectType);</code></pre>
<h3 id="non-uniffi-types-from-dependent-crates"><a class="header" href="#non-uniffi-types-from-dependent-crates">Non-UniFFI types from dependent crates</a></h3>
<p>If the dependent crate doesn't define the type in a UDL file or use one of the UniFFI derive macros,
then it's currently not possible to use them in an proc-macro exported interface.  However, we hope
to fix this limitation soon.</p>
<h2 id="other-limitations"><a class="header" href="#other-limitations">Other limitations</a></h2>
<p>In addition to the per-item limitations of the macros presented above, there is also currently a
global restriction: You can only use the proc-macros inside a crate whose name is the same as the
namespace in your UDL file. This restriction will be lifted in the future.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="asyncfuture-support"><a class="header" href="#asyncfuture-support">Async/Future support</a></h1>
<p>UniFFI supports exposing async Rust functions over the FFI. It can convert a Rust <code>Future</code>/<code>async fn</code> to and from foreign native futures (<code>async</code>/<code>await</code> in Python/Swift, <code>suspend fun</code> in Kotlin etc.)</p>
<p>Check out the <a href="https://github.com/mozilla/uniffi-rs/tree/main/examples/futures">examples</a> or the more terse and thorough <a href="https://github.com/mozilla/uniffi-rs/tree/main/fixtures/futures">fixtures</a>.</p>
<h2 id="example-1"><a class="header" href="#example-1">Example</a></h2>
<p>This is a short &quot;async sleep()&quot; example:</p>
<pre><code class="language-Rust">use std::time::Duration;
use async_std::future::{timeout, pending};

/// Async function that says something after a certain time.
#[uniffi::export]
pub async fn say_after(ms: u64, who: String) -&gt; String {
    let never = pending::&lt;()&gt;();
    timeout(Duration::from_millis(ms), never).await.unwrap_err();
    format!(&quot;Hello, {who}!&quot;)
}
</code></pre>
<p>This can be called by the following Python code:</p>
<pre><code class="language-python">import asyncio
from uniffi_example_futures import *

async def main():
    print(await say_after(20, 'Alice'))

if __name__ == '__main__':
    asyncio.run(main())
</code></pre>
<p>Async functions can also be defined in UDL:</p>
<pre><code class="language-idl">namespace example {
    [Async]
    string say_after(u64 ms, string who);
}
</code></pre>
<p>This code uses <code>asyncio</code> to drive the future to completion, while our exposed function is used with <code>await</code>.</p>
<p>In Rust <code>Future</code> terminology this means the foreign bindings supply the &quot;executor&quot; - think event-loop, or async runtime. In this example it's <code>asyncio</code>. There's no requirement for a Rust event loop.</p>
<p>There are <a href="https://docs.rs/uniffi_core/latest/uniffi_core/ffi/rustfuture/index.html">some great API docs</a> on the implementation that are well worth a read.</p>
<h2 id="exporting-async-trait-methods"><a class="header" href="#exporting-async-trait-methods">Exporting async trait methods</a></h2>
<p>UniFFI is compatible with the <a href="https://crates.io/crates/async-trait">async-trait</a> crate and this can
be used to export trait interfaces over the FFI.</p>
<p>When using UDL, wrap your trait with the <code>#[async_trait]</code> attribute.  In the UDL, annotate all async
methods with <code>[Async]</code>:</p>
<pre><code class="language-idl">[Trait]
interface SayAfterTrait {
    [Async]
    string say_after(u16 ms, string who);
};
</code></pre>
<p>When using proc-macros, make sure to put <code>#[uniffi::export]</code> outside the <code>#[async_trait]</code> attribute:</p>
<pre><code class="language-rust">#[uniffi::export]
#[async_trait::async_trait]
pub trait SayAfterTrait: Send + Sync {
    async fn say_after(&amp;self, ms: u16, who: String) -&gt; String;
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="generating-bindings"><a class="header" href="#generating-bindings">Generating bindings</a></h1>
<p>Bindings is the term used for the code generates for foreign languages which integrate
with Rust crates - that is, the generated Python, Swift or Kotlin code which drives the
examples.</p>
<p>UniFFI comes with a <code>uniffi_bindgen</code> which generates these bindings. For introductory
information, see <a href="./tutorial/foreign_language_bindings.html">Foreign Language Bindings in the tutorial</a></p>
<h1 id="customizing-the-binding-generation"><a class="header" href="#customizing-the-binding-generation">Customizing the binding generation.</a></h1>
<p>Each of the bindings reads a file <code>uniffi.toml</code> in the root of a crate which supports
various options which influence how the bindings are generated. Default options will be used
if this file is missing.</p>
<p><code>--config</code> option can be used to specify additional uniffi config file. This config is merged with
the <code>uniffi.toml</code> config present in each crate, with its values taking precedence.</p>
<p>Each binding supports different options, so please see the documentation for each binding language.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="generating-bindings-1"><a class="header" href="#generating-bindings-1">Generating bindings</a></h1>
<p>Bindings is the term used for the code generates for foreign languages which integrate
with Rust crates - that is, the generated Python, Swift or Kotlin code which drives the
examples.</p>
<p>UniFFI comes with a <code>uniffi_bindgen</code> which generates these bindings. For introductory
information, see <a href="./tutorial/foreign_language_bindings.html">Foreign Language Bindings in the tutorial</a></p>
<h1 id="customizing-the-binding-generation-1"><a class="header" href="#customizing-the-binding-generation-1">Customizing the binding generation.</a></h1>
<p>Each of the bindings reads a file <code>uniffi.toml</code> in the root of a crate which supports
various options which influence how the bindings are generated. Default options will be used
if this file is missing.</p>
<p><code>--config</code> option can be used to specify additional uniffi config file. This config is merged with
the <code>uniffi.toml</code> config present in each crate, with its values taking precedence.</p>
<p>Each binding supports different options, so please see the documentation for each binding language.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="foreign-traits"><a class="header" href="#foreign-traits">Foreign traits</a></h1>
<p>UniFFI traits can be implemented by foreign code.
This means traits implemented in Python/Swift/Kotlin etc can provide Rust code with capabilities not easily implemented in Rust, such as:</p>
<ul>
<li>device APIs not directly available to Rust.</li>
<li>provide glue to clip together Rust components at runtime.</li>
<li>access shared resources and assets bundled with the app.</li>
</ul>
<h1 id="example-2"><a class="header" href="#example-2">Example</a></h1>
<p>To implement a Rust trait in a foreign language, you might:</p>
<h2 id="1-define-a-rust-trait"><a class="header" href="#1-define-a-rust-trait">1. Define a Rust trait</a></h2>
<p>This toy example defines a way of Rust accessing a key-value store exposed
by the host operating system (e.g. the key chain).</p>
<p>All methods of the Rust trait should return a <code>Result&lt;&gt;</code> with the error half being
a <a href="./udl/errors.html">compatible error type</a> - see below for more on error handling.</p>
<p>For example:</p>
<pre><code class="language-rust no_run">pub trait Keychain: Send + Sync + Debug {
  fn get(&amp;self, key: String) -&gt; Result&lt;Option&lt;String&gt;, KeyChainError&gt;;
  fn put(&amp;self, key: String, value: String) -&gt; Result&lt;(), KeyChainError&gt;;
}</code></pre>
<p>If you are using macros add <code>#[uniffi::export]</code> above the trait.
Otherwise define this trait in your UDL file:</p>
<pre><code class="language-webidl">[Trait]
interface Keychain {
    [Throws=KeyChainError]
    string? get(string key);

    [Throws=KeyChainError]
    void put(string key, string data);
};
</code></pre>
<h2 id="2-allow-it-to-be-passed-into-rust"><a class="header" href="#2-allow-it-to-be-passed-into-rust">2. Allow it to be passed into Rust</a></h2>
<p>Here, we define a new object with a constructor which takes a keychain.</p>
<pre><code class="language-webidl">interface Authenticator {
    constructor(Keychain keychain);
    void login();
};
</code></pre>
<p>In Rust we'd write:</p>
<pre><code class="language-rust no_run">struct Authenticator {
  keychain: Arc&lt;dyn Keychain&gt;,
}

impl Authenticator {
  pub fn new(keychain: Arc&lt;dyn Keychain&gt;) -&gt; Self {
    Self { keychain }
  }

  pub fn login(&amp;self) {
    let username = self.keychain.get(&quot;username&quot;.into());
    let password = self.keychain.get(&quot;password&quot;.into());
  }
}</code></pre>
<h2 id="3-create-a-foreign-language-implementation-of-the-trait"><a class="header" href="#3-create-a-foreign-language-implementation-of-the-trait">3. Create a foreign language implementation of the trait</a></h2>
<p>Here's a Kotlin implementation:</p>
<pre><code class="language-kotlin">class KotlinKeychain: Keychain {
    override fun get(key: String): String? {
        // … elide the implementation.
        return value
    }
    override fun put(key: String) {
        // … elide the implementation.
    }
}
</code></pre>
<p>…and Swift:</p>
<pre><code class="language-swift">class SwiftKeychain: Keychain {
    func get(key: String) -&gt; String? {
        // … elide the implementation.
        return value
    }
    func put(key: String) {
        // … elide the implementation.
    }
}
</code></pre>
<h2 id="4-pass-the-implementation-to-rust"><a class="header" href="#4-pass-the-implementation-to-rust">4. Pass the implementation to Rust</a></h2>
<p>Again, in Kotlin</p>
<pre><code class="language-kt">val authenticator = Authenticator(KotlinKeychain())
// later on:
authenticator.login()
</code></pre>
<p>and in Swift:</p>
<pre><code class="language-swift">let authenticator = Authenticator(SwiftKeychain())
// later on:
authenticator.login()
</code></pre>
<p>Care is taken to ensure that things are cleaned up in the foreign language once all Rust references drop.</p>
<h2 id="--avoid-cycles"><a class="header" href="#--avoid-cycles">⚠️  Avoid cycles</a></h2>
<p>Foreign trait implementations make it easy to create cycles between Rust and foreign objects causing memory leaks.
For example a foreign implementation holding a reference to a Rust object which also holds a reference to the same foreign implementation.</p>
<p>UniFFI doesn't try to help here and there's no universal advice; take the usual precautions.</p>
<h1 id="error-handling"><a class="header" href="#error-handling">Error handling</a></h1>
<p>We must handle foreign code failing, so all methods of the Rust trait should return a <code>Result&lt;&gt;</code> with a <a href="./udl/errors.html">compatible error type</a> otherwise these errors will panic.</p>
<h2 id="unexpected-error-handling"><a class="header" href="#unexpected-error-handling">Unexpected Error handling.</a></h2>
<p>So long as your function returns a <code>Result&lt;&gt;</code>, it's possible for you to define how &quot;unexpected&quot; errors
(ie, errors not directly covered by your <code>Result&lt;&gt;</code> type, panics, etc) are converted to your <code>Result&lt;&gt;</code>'s <code>Err</code>.</p>
<p>If your code defines a <code>From&lt;uniffi::UnexpectedUniFFICallbackError&gt;</code> impl for your error type, then those errors will be converted into your error type which will be returned to the Rust caller.
If your code does not define this implementation the generated code will panic.
In other words, you really should implement this!</p>
<p>See our <a href="https://github.com/mozilla/uniffi-rs/tree/main/examples/callbacks">callbacks example</a> for more.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="configuration"><a class="header" href="#configuration">Configuration</a></h1>
<p>The generated Kotlin modules can be configured using a <code>uniffi.toml</code> configuration file.</p>
<h2 id="available-options"><a class="header" href="#available-options">Available options</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Configuration name</th><th>Default</th><th>Description</th></tr></thead><tbody>
<tr><td><code>package_name</code></td><td><code>uniffi</code></td><td>The Kotlin package name - ie, the value used in the <code>package</code> statement at the top of generated files.</td></tr>
<tr><td><code>cdylib_name</code></td><td><code>uniffi_{namespace}</code><sup class="footnote-reference"><a href="#1">1</a></sup></td><td>The name of the compiled Rust library containing the FFI implementation (not needed when using <code>generate --library</code>).</td></tr>
<tr><td><code>generate_immutable_records</code></td><td><code>false</code></td><td>Whether to generate records with immutable fields (<code>val</code> instead of <code>var</code>).</td></tr>
<tr><td><code>custom_types</code></td><td></td><td>A map which controls how custom types are exposed to Kotlin. See the <a href="kotlin/../udl/custom_types.html#custom-types-in-the-bindings-code">custom types section of the manual</a></td></tr>
<tr><td><code>external_packages</code></td><td></td><td>A map of packages to be used for the specified external crates. The key is the Rust crate name, the value is the Kotlin package which will be used referring to types in that crate. See the <a href="kotlin/../udl/ext_types_external.html#kotlin">external types section of the manual</a></td></tr>
<tr><td><code>android</code></td><td><code>false</code></td><td>Used to toggle on Android specific optimizations</td></tr>
<tr><td><code>android_cleaner</code></td><td><code>android</code></td><td>Use the <a href="https://developer.android.com/reference/android/system/SystemCleaner"><code>android.system.SystemCleaner</code></a> instead of <a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/ref/Cleaner.html"><code>java.lang.ref.Cleaner</code></a>. Fallback in both instances is the one shipped with JNA.</td></tr>
</tbody></table>
</div>
<h2 id="example-3"><a class="header" href="#example-3">Example</a></h2>
<p>Custom types</p>
<pre><code class="language-toml"># Assuming a Custom Type named URL using a String as the builtin.
[bindings.kotlin.custom_types.Url]
# Name of the type in the Kotlin code
type_name = &quot;URL&quot;
# Classes that need to be imported
imports = [ &quot;java.net.URI&quot;, &quot;java.net.URL&quot; ]
# Functions to convert between strings and URLs
into_custom = &quot;URI({}).toURL()&quot;
from_custom = &quot;{}.toString()&quot;
</code></pre>
<p>External types</p>
<pre><code class="language-toml">[bindings.kotlin.external_packages]
# This specifies that external types from the crate `rust-crate-name` will be referred by by the package `&quot;kotlin.package.name`.
rust-crate-name = &quot;kotlin.package.name&quot;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="integrating-with-gradle"><a class="header" href="#integrating-with-gradle">Integrating with Gradle</a></h1>
<p>It is possible to generate Kotlin bindings at compile time for Kotlin Android projects. We'd like to make a gradle plugin for that, but until then you can add to your <code>build.gradle</code> the following:</p>
<pre><code class="language-groovy">android.libraryVariants.all { variant -&gt;
    def t = tasks.register(&quot;generate${variant.name.capitalize()}UniFFIBindings&quot;, Exec) {
        workingDir &quot;${project.projectDir}&quot;
        // Runs the bindings generation, note that you must have uniffi-bindgen installed and in your PATH environment variable
        commandLine 'uniffi-bindgen', 'generate', '&lt;PATH TO .udl FILE&gt;', '--language', 'kotlin', '--out-dir', &quot;${buildDir}/generated/source/uniffi/${variant.name}/java&quot;
    }
    variant.javaCompileProvider.get().dependsOn(t)
    def sourceSet = variant.sourceSets.find { it.name == variant.name }
    sourceSet.java.srcDir new File(buildDir, &quot;generated/source/uniffi/${variant.name}/java&quot;)
    // XXX: I've been trying to make this work but I can't, so the compiled bindings will show as &quot;regular sources&quot; in Android Studio.
    idea.module.generatedSourceDirs += file(&quot;${buildDir}/generated/source/uniffi/${variant.name}/java/uniffi&quot;)
}
</code></pre>
<p>The generated bindings should appear in the project sources in Android Studio.</p>
<h2 id="using-experimental-unsigned-types"><a class="header" href="#using-experimental-unsigned-types">Using experimental unsigned types</a></h2>
<p>Unsigned integers in the defined API are translated to their equivalents in the foreign language binding, e.g. <code>u32</code> becomes Kotlin's <code>UInt</code> type.
See <a href="kotlin/../udl/builtin_types.html">Built-in types</a>.</p>
<p>However unsigned integer types are experimental in Kotlin versions prior to 1.5.
As such they require explicit annotations to suppress warnings.
Uniffi is trying to add these annotations where necessary,
but currently misses some places, see <a href="https://github.com/mozilla/uniffi-rs/pull/977">PR #977</a> for details.</p>
<p>To suppress all warnings for experimental unsigned types add this to your project's <code>build.gradle</code> file:</p>
<pre><code class="language-groovy">allprojects {
   tasks.withType(org.jetbrains.kotlin.gradle.tasks.KotlinCompile).all {
        kotlinOptions {
            freeCompilerArgs += [
                &quot;-Xuse-experimental=kotlin.ExperimentalUnsignedTypes&quot;,
            ]
        }
    }
}
</code></pre>
<blockquote>
<h2 id="update"><a class="header" href="#update">Update</a></h2>
<p>As of <a href="https://github.com/mozilla/uniffi-rs/pull/993">PR #993</a>, the Kotlin backend was refactored, and it became harder to support the
<code>@ExperimentalUnsignedTypes</code> annotation. Uniffi's Android customers are rapidly moving toward Kotlin 1.5, so adding this compiler arg is no longer necessary.</p>
</blockquote>
<h2 id="jna-dependency"><a class="header" href="#jna-dependency">JNA dependency</a></h2>
<p>UniFFI relies on <a href="https://github.com/java-native-access/jna">JNA</a> for the ability to call native methods.
JNA 5.12.0 or greater is required.</p>
<p>Set the dependency in your <code>build.gradle</code>:</p>
<pre><code class="language-groovy">dependencies {
    implementation &quot;net.java.dev.jna:jna:5.12.0@aar&quot;
}
</code></pre>
<h2 id="coroutines-dependency"><a class="header" href="#coroutines-dependency">Coroutines dependency</a></h2>
<p>UniFFI relies on <a href="https://github.com/Kotlin/kotlinx.coroutines">kotlinx coroutines core</a> for future and async support. Version 1.6 or greater is required.</p>
<p>Set the dependency in your <code>build.gradle</code>:</p>
<pre><code class="language-groovy">dependencies {
    implementation &quot;org.jetbrains.kotlinx:kotlinx-coroutines-core:1.6.4&quot;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="kotlin-lifetimes"><a class="header" href="#kotlin-lifetimes">Kotlin Lifetimes</a></h1>
<p>All interfaces exposed via Kotlin expose a public API for freeing
the Kotlin wrapper object in lieu of reliable finalizers. This is done
by making the &quot;base class&quot; for all such generated objects implement the
<code>Disposable</code> and <code>AutoCloseable</code> interfaces.</p>
<p>As such, these wrappers all implement a <code>close()</code> method, which must be
explicitly called to ensure the associated Rust resources are reclaimed.</p>
<p>The best way to arrange for this to be called at the right time is beyond
the scope of this document; you should consult the official documentation for
<code>AutoClosable</code>, but one common pattern is the Kotlin
<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/use.html">use function</a>.</p>
<h2 id="nested-objects"><a class="header" href="#nested-objects">Nested objects</a></h2>
<p>We also need to consider what happens when objects are contained in other objects.
The current situation is:</p>
<ul>
<li>
<p>Dictionaries that contain interfaces implement <code>AutoClosable</code> with their close() method closing
any contained interfaces.</p>
</li>
<li>
<p>Enums can't currently contain interfaces.</p>
</li>
<li>
<p>Lists/Maps don't implement <code>AutoClosable</code>; if you have a list/map of interfaces
you need to close each one individually.</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="swift-bindings"><a class="header" href="#swift-bindings">Swift Bindings</a></h1>
<p>UniFFI ships with production-quality support for generating Swift bindings.
Concepts from the UDL file map into Swift as follows:</p>
<ul>
<li>Primitive datatypes map to their obvious Swift counterpart, e.g. <code>u32</code> becomes <code>UInt32</code>,
<code>string</code> becomes <code>String</code>, <code>bytes</code> becomes <code>Data</code>, etc.</li>
<li>An object interface declared as <code>interface T</code> is represented as a Swift <code>protocol TProtocol</code>
and a concrete Swift <code>class T</code> that conforms to it. Having the protocol declared explicitly
can be useful for mocking instances of the class in unittests.</li>
<li>A dictionary struct declared as <code>dictionary T</code> is represented as a Swift <code>struct T</code>
with public mutable fields.</li>
<li>An enum declared <code>enum T</code> or <code>[Enum] interface T</code> is represented as a Swift
<code>enum T</code> with appropriate variants.</li>
<li>Optional types are represented using Swift's builtin optional type syntax <code>T?</code>.</li>
<li>Sequences are represented as Swift arrays, and Maps as Swift dictionaries.</li>
<li>Errors are represented as Swift enums that conform to the <code>Error</code> protocol.</li>
<li>Function calls that have an associated error type are marked with <code>throws</code>,
and hence must be called using one of Swift's <code>try</code> syntax variants.</li>
<li>Failing assertions, Rust panics, and other unexpected errors in the generated code
are translated into a private enum conforming to the <code>Error</code> protocol.
<ul>
<li>If this happens inside a throwing Swift function, it can be caught and handled
by a catch-all <code>catch</code> statement (but do so at your own risk, because it indicates
that something has gone seriously wrong).</li>
<li>If this happens inside a non-throwing Swift function, it will be converted
into a fatal Swift error that cannot be caught.</li>
</ul>
</li>
</ul>
<p>Conceptually, the generated bindings are split into two Swift modules, one for the low-level
C FFI layer and one for the higher-level Swift bindings. For a UniFFI component named &quot;example&quot;
we generate:</p>
<ul>
<li>A C header file <code>exampleFFI.h</code> declaring the low-level structs and functions for calling
into Rust, along with a corresponding <code>exampleFFI.modulemap</code> to expose them to Swift.</li>
<li>A Swift source file <code>example.swift</code> that imports the <code>exampleFFI</code> module and wraps it
to provide the higher-level Swift API.</li>
</ul>
<p>Splitting up the bindings in this way gives you flexibility over how both the Rust code
and the Swift code are distributed to consumers. For example, you may choose to compile
and distribute the Rust code for several UniFFI components as a single shared library
in order to reduce the compiled code size, while distributing their Swift wrappers as
individual modules.</p>
<p>For more technical details on how the bindings work internally, please see the
<a href="swift/../internals/api/uniffi_bindgen/bindings/swift/index.html">module documentation</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="configuration-1"><a class="header" href="#configuration-1">Configuration</a></h1>
<p>The generated Swift module can be configured using a <code>uniffi.toml</code> configuration file.</p>
<h2 id="available-options-1"><a class="header" href="#available-options-1">Available options</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Configuration name</th><th>Default</th><th>Description</th></tr></thead><tbody>
<tr><td><code>cdylib_name</code></td><td><code>uniffi_{namespace}</code><sup class="footnote-reference"><a href="#1">1</a></sup></td><td>The name of the compiled Rust library containing the FFI implementation (not needed when using <code>generate --library</code>).</td></tr>
<tr><td><code>module_name</code></td><td><code>{namespace}</code><sup class="footnote-reference"><a href="#1">1</a></sup></td><td>The name of the Swift module containing the high-level foreign-language bindings.</td></tr>
<tr><td><code>ffi_module_name</code></td><td><code>{module_name}FFI</code></td><td>The name of the lower-level C module containing the FFI declarations.</td></tr>
<tr><td><code>ffi_module_filename</code></td><td><code>{ffi_module_name}</code></td><td>The filename stem for the lower-level C module containing the FFI declarations.</td></tr>
<tr><td><code>generate_module_map</code></td><td><code>true</code></td><td>Whether to generate a <code>.modulemap</code> file for the lower-level C module with FFI declarations.</td></tr>
<tr><td><code>omit_argument_labels</code></td><td><code>false</code></td><td>Whether to omit argument labels in Swift function definitions.</td></tr>
<tr><td><code>generate_immutable_records</code></td><td><code>false</code></td><td>Whether to generate records with immutable fields (<code>let</code> instead of <code>var</code>).</td></tr>
<tr><td><code>custom_types</code></td><td></td><td>A map which controls how custom types are exposed to Swift. See the <a href="swift/../udl/custom_types.html#custom-types-in-the-bindings-code">custom types section of the manual</a></td></tr>
</tbody></table>
</div>
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p><code>namespace</code> is the top-level namespace from your UDL file.</p>
</div>
<h2 id="example-4"><a class="header" href="#example-4">Example</a></h2>
<pre><code class="language-toml">[bindings.swift]
cdylib_name = &quot;mycrate_ffi&quot;
omit_argument_labels = true
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="compiling-a-swift-module"><a class="header" href="#compiling-a-swift-module">Compiling a Swift module</a></h1>
<p>Before you can import the generated Swift bindings as a module (say, to use them
from your application, or to try them out using <code>swift</code> on the command-line) you
first need to compile them into a Swift module.</p>
<p>To do so, you'll need both the generated <code>.swift</code> file and the corresponding
<code>.modulemap</code> file, which tells Swift how to expose the underlying C FFI layer.
Use <code>swiftc</code> to combine the cdylib from your Rust crate with the generated
Swift bindings:</p>
<pre><code>swiftc
    -module-name example                         # Name for resulting Swift module
    -emit-library -o libexample.dylib            # File to link with if using Swift REPL
    -emit-module -emit-module-path ./            # Output directory for resulting module
    -parse-as-library
    -L ./target/debug/                           # Directory containing compiled Rust crate
    -lexample                                    # Name of compiled Rust crate cdylib
    -Xcc -fmodule-map-file=exampleFFI.modulemap  # The modulemap file from above
    example.swift                                # The generated bindings file
</code></pre>
<p>This will produce an <code>example.swiftmodule</code> file that can be loaded by
other Swift code or used from the Swift command-line REPL.</p>
<p>If you are creating an XCFramework with this code, make sure to rename the modulemap file
to <code>module.modulemap</code>, the default value expected by Clang and XCFrameworks for exposing
the C FFI library to Swift.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="integrating-with-xcode"><a class="header" href="#integrating-with-xcode">Integrating with Xcode</a></h1>
<p>It is possible to generate Swift bindings at compile time for Xcode projects
and incorporate them alongside hand-written Swift code to form a larger module.
Broadly, you will need to:</p>
<ol>
<li>Add a build phase to compile the Rust crate into a static lib and link it
into your framework.</li>
<li>Add a build phase to run <code>uniffi-bindgen </code> and generate the Swift bindings.</li>
<li>Include the generated bridging header into your overall bridging header.</li>
</ol>
<p>There is also an example app in the UniFFI project repo that may be helpful.</p>
<h2 id="compiling-the-rust-crate"><a class="header" href="#compiling-the-rust-crate">Compiling the Rust crate.</a></h2>
<p>Sorry, configuring Xcode to compile the Rust crate into a staticlib
is beyond the scope of this document. However you do so, make sure you
include the resulting <code>libexample.a</code> file in the &quot;Link Binary with Libraries&quot;
build phase for your framework.</p>
<p>This repository contains an example iOS app (at <code>./examples/app/ios</code>) which
may be useful for reference. It contains an <code>xc-universal-binary.sh</code> shell
script which can invoke <code>cargo</code> with the necessary settings to produce a
static library of Rust code.</p>
<h2 id="generating-the-bindings"><a class="header" href="#generating-the-bindings">Generating the bindings</a></h2>
<p>In the &quot;Build Rules&quot; section of your config, add a rule to process <code>.udl</code> files
using <code>uniffi-bindgen</code>. We recommend having it generate the output files
somewhere in your source tree, rather than in Xcode's default <code>$DERIVED_FILE_DIR</code>;
this both helps with debugging the build output, and makes it easier to configure
how the generated files are used.</p>
<ul>
<li>Add a build rule processing files with names matching <code>*.udl</code>.
<ul>
<li>Use something like the following as the custom script:
<ul>
<li><code>$HOME/.cargo/bin/uniffi-bindgen generate $INPUT_FILE_PATH --language swift --out-dir $INPUT_FILE_DIR/Generated</code></li>
</ul>
</li>
<li>Add both the <code>.swift</code> file and the generated bridging header as output files:
<ul>
<li><code>$(INPUT_FILE_DIR)/Generated/$(INPUT_FILE_BASE).swift</code></li>
<li><code>$(INPUT_FILE_DIR)/Generated/$(INPUT_FILE_BASE)FFI.h</code></li>
</ul>
</li>
</ul>
</li>
<li>Add your <code>.udl</code> file to the &quot;Compile Sources&quot; build phase for your framework,
so that Xcode will process it using the new build rule and will include the resulting
outputs in the build.</li>
</ul>
<p>You do <em>not</em> need to add the generated Swift code to the list of &quot;Compile Sources&quot;
and should not attempt to compile it explicitly; Xcode will figure out what it
needs to do with this code based on it being generated from the Build Rule for
your .udl file.</p>
<h2 id="including-the-bridging-header"><a class="header" href="#including-the-bridging-header">Including the bridging header</a></h2>
<p>In the overall bridging header for your module, include the header file
generated by UniFFI in the previous step:</p>
<pre><code>#include &quot;exampleFFI.h&quot;
</code></pre>
<p>For this to work without complaint from Xcode, you also need to add the
generated header file as a <strong>Public</strong> header in the &quot;Headers&quot; build phase
of your project (which is why it's useful to generate this file somewhere in
your source tree, rather than in a temporary build directory).</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="configuration-2"><a class="header" href="#configuration-2">Configuration</a></h1>
<p>The generated Python modules can be configured using a <code>uniffi.toml</code> configuration file.</p>
<h2 id="available-options-2"><a class="header" href="#available-options-2">Available options</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Configuration name</th><th>Default</th><th>Description</th></tr></thead><tbody>
<tr><td><code>cdylib_name</code></td><td><code>uniffi_{namespace}</code><sup class="footnote-reference"><a href="#1">1</a></sup></td><td>The name of the compiled Rust library containing the FFI implementation (not needed when using <code>generate --library</code>).</td></tr>
<tr><td><code>custom_types</code></td><td></td><td>A map which controls how custom types are exposed to Python. See the <a href="python/../udl/custom_types.html#custom-types-in-the-bindings-code">custom types section of the manual</a></td></tr>
<tr><td><code>external_packages</code></td><td></td><td>A map which controls the package name used by external packages. See below for more.</td></tr>
</tbody></table>
</div>
<h2 id="external-packages"><a class="header" href="#external-packages">External Packages</a></h2>
<p>When you reference external modules, uniffi will generate statements like <code>from module import Type</code>
in the referencing module. The <code>external_packages</code> configuration value allows you to specify how <code>module</code>
is formed in such statements.</p>
<p>The value is a map, keyed by the crate-name and the value is the package name which will be used by
Python for that crate. The default value is an empty map.</p>
<p>When looking up crate-name, the following behavior is implemented.</p>
<h3 id="default-value"><a class="header" href="#default-value">Default value</a></h3>
<p>If no value for the crate is found, it is assumed that you will be packaging up your library
as a simple Python package, so the statement will be of the form <code>from .module import Type</code>,
where <code>module</code> is the namespace specified in that crate.</p>
<p>Note that this is invalid syntax unless the module lives in a package - attempting to
use the module as a stand-alone module will fail. UniFFI just generates flat .py files; the
packaging is up to you. Eg, a build process might create a directory, create an <code>__init__.py</code>
file in that directory (maybe including <code>from subpackage import *</code>) and have <code>uniffi-bindgen</code>
generate the bindings into this directory.</p>
<h3 id="specified-value"><a class="header" href="#specified-value">Specified value</a></h3>
<p>If the crate-name is found in the map, the specified entry used as a package name, so the statement will be of the form
<code>from package.module import Type</code> (again, where <code>module</code> is the namespace specified in that crate)</p>
<p>An exception is when the specified value is an empty string, in which case you will see
<code>from module import Type</code>, so each generated module functions outside a package.
This is used by some UniFFI tests to avoid the test code needing to create a Python package.</p>
<h2 id="examples"><a class="header" href="#examples">Examples</a></h2>
<p>Custom Types</p>
<pre><code class="language-toml"># Assuming a Custom Type named URL using a String as the builtin.
[bindings.python.custom_types.Url]
imports = [&quot;urllib.parse&quot;]
# Functions to convert between strings and the ParsedUrl class
into_custom = &quot;urllib.parse.urlparse({})&quot;
from_custom = &quot;urllib.parse.urlunparse({})&quot;
</code></pre>
<p>External Packages</p>
<pre><code class="language-toml">[bindings.python.external_packages]
# An external type `Foo` in `crate-name` (which specifies a namespace of `my_module`) will be referenced via `from MyPackageName.my_module import Foo`
crate-name = &quot;MyPackageName&quot;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="design-principles"><a class="header" href="#design-principles">Design Principles</a></h1>
<p>These are some high-level points to consider when making changes to UniFFI (or when wondering why past changes were made in a particular way).</p>
<h3 id="prioritize-mozillas-short-term-needs"><a class="header" href="#prioritize-mozillas-short-term-needs">Prioritize Mozilla's short-term needs</a></h3>
<p>The initial consumers of this tool are teams working on features for Mozilla's mobile browsers.
While we try to make the tool generally useful, we'll invest first in things that are the most valuable
to those teams, which are reflected in the points below.</p>
<h3 id="safety-first"><a class="header" href="#safety-first">Safety First</a></h3>
<p>The generated bindings need to be safe by default. It should be impossible for foreign-language code
to trigger undefined behaviour in Rust by calling the public API of the generated bindings, even if it
is called in egregiously wrong or malicious ways. We will accept reduced performance in the interests
of ensuring this safety.</p>
<p>(The meaning of &quot;impossible&quot; and &quot;public API&quot; will of course depend on the target language. For example,
code in Python might mutate internal attributes of an object that are marked as private with a leading
underscore, and there's not much we can do to guard against that.)</p>
<p>Where possible, we use Rust's typesystem to encode safety guarantees. If that's not possible then the
generated Rust code may use <code>unsafe</code> and assume that the generated foreign-language code will uphold
safety guarantees at runtime.</p>
<p><strong>Example:</strong> We insist that all object instances exposed to foreign-language code be <code>Sync</code> and <code>Send</code>,
so that they're safe to access regardless of the threading model of the calling code. We do not allow
thread-safety guarantees to be deferred to assumptions about how the code is called.</p>
<p><strong>Example:</strong> We do not allow returning any borrowed data from function calls, because we can't make
any guarantees about when or how the foreign-language could access it.</p>
<h3 id="performance-is-a-feature-but-not-a-deal-breaker"><a class="header" href="#performance-is-a-feature-but-not-a-deal-breaker">Performance is a feature, but not a deal-breaker</a></h3>
<p>Our initial use-cases are not performance-critical, and our team are not low-level Rust experts,
so we're highly motivated to favour simplicity and maintainability over performance. Given the choice
we will pick &quot;simple but slow&quot; over &quot;fast but complicated&quot;.</p>
<p>However, we know that performance can degrade through thousands of tiny cuts, so we'll keep iterating
towards the winning combination of &quot;simple <em>and</em> fast&quot; over time.</p>
<p><strong>Example:</strong> Initial versions of the tool used opaque integer handles and explicit mutexes to manage
object references, favouring simplicity (in the &quot;we're confident this works as intended&quot; sense) over
performance. As we got more experience and confidence with the approach and tool we replaced handles with
raw <code>Arc</code> pointers, which both simplified the code and removed some runtime overheads.</p>
<p><strong>Violation:</strong> The tool currently passes structured data over the FFI by serializing it to a byte
buffer, favouring ease of implementation and understanding over performance. This was fine as a starting
point! However, we have not done any work to measure the performance impact or iterate towards something
with lower overhead (such as using <code>repr(C)</code> structs).</p>
<h3 id="produce-bindings-that-feel-idiomatic-for-the-target-language"><a class="header" href="#produce-bindings-that-feel-idiomatic-for-the-target-language">Produce bindings that feel idiomatic for the target language</a></h3>
<p>The generated bindings should feel idiomatic for their end users, and what feels idiomatic can differ
between different target languages. Ideally consumers should not even realize that they're using
bindings to Rust under the hood.</p>
<p>We'll accept extra complexity inside of UniFFI if it means producing bindings that are nicer for consumers to use.</p>
<p><strong>Example:</strong> We case-convert names to match the accepted standards of the target language,
so a method named <code>do_the_thing</code> in Rust might be called <code>doTheThing</code> in its Kotlin bindings.</p>
<p><strong>Example:</strong> Object references try to integrate with the GC of the target language, so that holding
a reference to a Rust struct feels like holding an ordinary object instance.</p>
<p><strong>Violation:</strong> The Kotlin bindings have an explicit <code>destroy</code> method on object instances, because we haven't
yet found a good way to integrate with the JVM's GC.</p>
<h3 id="empower-users-to-debug-and-maintain-the-tool"><a class="header" href="#empower-users-to-debug-and-maintain-the-tool">Empower users to debug and maintain the tool</a></h3>
<p>To succeed long-term, we can't depend on a dedicated team of &quot;UniFFI experts&quot; for debugging and maintenance.
The people using the tool need to be empowered to debug, maintain and develop it.</p>
<p>If you're using UniFFI-generated bindings and something doesn't work quite right, it should be possible
for you to dig in to the generated foreign-language code, follow it through to the underlying Rust code,
and work out what's going wrong without being an expert in Rust or UniFFI.</p>
<p><strong>Example:</strong> We try to include comments in the generated code to help guide users who may be reading
through it to debug some issue.</p>
<p><strong>Violation:</strong> We don't have very good &quot;overview&quot; documentation on how each set of foreign-language bindings
works, so someone trying to debug the Kotlin bindings would need to poke around in the generated code to
try to build up a mental model of how it's supposed to work.</p>
<p><strong>Violation:</strong> A lack of structure in our code-generation templates means that it's hard for non-experts
to find and change the codegen logic for a particular piece of functionality.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="navigating-the-code"><a class="header" href="#navigating-the-code">Navigating the code</a></h1>
<p>The code for UniFFI is organized into the following crates:</p>
<ul>
<li><strong><a href="internals/./api/uniffi_bindgen/index.html"><code>./uniffi_bindgen</code></a>:</strong> This is the source for the <code>uniffi-bindgen</code> executable and is where
most of the logic for the UniFFI tool lives. Its contents include:
<ul>
<li><strong><a href="internals/./api/uniffi_bindgen/interface/index.html"><code>./uniffi_bindgen/src/interface/</code></a>:</strong> The logic for parsing <code>.udl</code> files
into an in-memory representation called <a href="internals/./api/uniffi_bindgen/interface/struct.ComponentInterface.html"><code>ComponentInterface</code></a>,
from which we can generate code for different languages.</li>
<li><strong><a href="internals/./api/uniffi_bindgen/scaffolding/index.html"><code>./uniffi_bindgen/src/scaffolding</code></a>:</strong> This module turns a
<a href="internals/./api/uniffi_bindgen/interface/struct.ComponentInterface.html"><code>ComponentInterface</code></a> into <em>Rust scaffolding</em>, the code that
wraps the user-provided Rust code and exposes it via a C-compatible FFI layer.</li>
<li><strong><a href="internals/./api/uniffi_bindgen/bindings/index.html"><code>./uniffi_bindgen/src/bindings/</code></a>:</strong> This module turns a
<a href="internals/./api/uniffi_bindgen/interface/struct.ComponentInterface.html"><code>ComponentInterface</code></a> into <em>foreign-language bindings</em>,
the code that can load the FFI layer exposed by the scaffolding and expose it as a
higher-level API in a target language. There is a sub-module for each supported language.</li>
</ul>
</li>
<li><strong><a href="internals/./api/uniffi/index.html"><code>./uniffi</code></a>:</strong> This is a run-time support crate that is used by the generated Rust scaffolding. It
controls how values of various types are passed back-and-forth over the FFI layer, by means of the
<a href="internals/./api/uniffi/trait.FfiConverter.html"><code>FfiConverter</code></a> trait.</li>
<li><strong><a href="internals/./api/uniffi_build/index.html"><code>./uniffi_build</code></a>:</strong> This is a small hook to run <code>uniffi-bindgen</code> from the <code>build.rs</code> script
of a UniFFI component, in order to automatically generate the Rust scaffolding as part of its build process.</li>
<li><strong><a href="internals/./api/uniffi_macros/index.html"><code>./uniffi_macros</code></a>:</strong> This contains some helper macros that UniFFI components can use to
simplify loading the generated scaffolding, and executing foreign-language tests.</li>
<li><strong><a href="https://github.com/mozilla/uniffi-rs/tree/main/examples"><code>./examples</code></a>:</strong>
This contains code examples that you can use to explore the code generation
process.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lifting-lowering-and-serialization"><a class="header" href="#lifting-lowering-and-serialization">Lifting, Lowering and Serialization</a></h1>
<p>UniFFI is able to transfer rich data types back-and-forth between the Rust
code and the foreign-language code via a process we refer to as &quot;lowering&quot;
and &quot;lifting&quot;.</p>
<p>Recall that UniFFI interoperates between different languages by defining
a C-style FFI layer which operates in terms of primitive data types and
plain functions. To transfer data from one side of this layer to the other,
the sending side &quot;<em><strong>lowers</strong></em>&quot; the data from a language-specific data type
into one of the primitive types supported by the FFI-layer functions, and the
receiving side &quot;<em><strong>lifts</strong></em>&quot; that primitive type into its own language-specific
data type.</p>
<p>Lifting and lowering simple types such as integers is done by directly casting the
value to and from an appropriate type. For complex types such as optionals and
records we currently implement lifting and lowering by serializing into a byte
buffer, but this is an implementation detail that may change in future. (See
<a href="https://github.com/mozilla/uniffi-rs/blob/main/docs/adr/0002-serialize-complex-datatypes.md">ADR-0002</a> for the reasoning
behind this choice.)</p>
<p>As a concrete example, consider this interface for accumulating a list of integers:</p>
<pre><code class="language-idl">namespace example {
  sequence&lt;i32&gt; add_to_list(i32 item);
}
</code></pre>
<p>Calling this function from foreign language code involves the following steps:</p>
<ol>
<li>The user-provided calling code invokes the <code>add_to_list</code> function that is exposed by the
UniFFI-generated foreign language bindings, passing <code>item</code> as an appropriate language-native
integer.</li>
<li>The foreign language bindings <em><strong>lower</strong></em> each argument to a function call into
something that can be passed over the C-style FFI. Since the <code>item</code> argument is a plain integer,
it is lowered by casting to an <code>int32_t</code>.</li>
<li>The foreign language bindings pass the lowered arguments to a C FFI function named
like <code>example_XYZ_add_to_list</code> that is exposed by the UniFFI-generated Rust scaffolding.</li>
<li>The Rust scaffolding <em><strong>lifts</strong></em> each argument received over the FFI into a native
Rust type. Since <code>item</code> is a plain integer it is lifted by casting to a Rust <code>i32</code>.</li>
<li>The Rust scaffolding passes the lifted arguments to the user-provided Rust code for
the <code>add_to_list</code> function, which returns a <code>Vec&lt;i32&gt;</code>.</li>
<li>The Rust scaffolding now needs to <em><strong>lower</strong></em> the return value in order to pass it back
to the foreign language code. Since this is a complex data type, it is lowered by serializing
the values into a byte buffer and returning the buffer pointer and length from the
FFI function.</li>
<li>The foreign language bindings receive the return value and need to <em><strong>lift</strong></em> it into an
appropriate native data type. Since it is a complex data type, it is lifted by deserializing
from the returned byte buffer into a language-native list of integers.</li>
</ol>
<h2 id="lowered-types"><a class="header" href="#lowered-types">Lowered Types</a></h2>
<div class="table-wrapper"><table><thead><tr><th>UDL Type</th><th>Representation in the C FFI</th></tr></thead><tbody>
<tr><td><code>i8</code>/<code>i16</code>/<code>i32</code>/<code>i64</code></td><td><code>int8_t</code>/<code>int16_t</code>/<code>int32_t</code>/<code>int64_t</code></td></tr>
<tr><td><code>u8</code>/<code>u16</code>/<code>u32</code>/<code>u64</code></td><td><code>uint8_t</code>/<code>uint16_t</code>/<code>uint32_t</code>/<code>uint64_t</code></td></tr>
<tr><td><code>f32</code>/<code>float</code></td><td><code>float</code></td></tr>
<tr><td><code>f64</code>/<code>double</code></td><td><code>double</code></td></tr>
<tr><td><code>boolean</code></td><td><code>int8_t</code>, either <code>0</code> or <code>1</code></td></tr>
<tr><td><code>string</code></td><td><code>RustBuffer</code> struct pointing to utf8 bytes</td></tr>
<tr><td><code>bytes</code></td><td>Same as <code>sequence&lt;u8&gt;</code></td></tr>
<tr><td><code>timestamp</code></td><td><code>RustBuffer</code> struct pointing to a i64 representing seconds and a u32 representing nanoseconds</td></tr>
<tr><td><code>duration</code></td><td><code>RustBuffer</code> struct pointing to a u64 representing seconds and a u32 representing nanoseconds</td></tr>
<tr><td><code>T?</code></td><td><code>RustBuffer</code> struct pointing to serialized bytes</td></tr>
<tr><td><code>sequence&lt;T&gt;</code></td><td><code>RustBuffer</code> struct pointing to serialized bytes</td></tr>
<tr><td><code>record&lt;string, T&gt;</code></td><td><code>RustBuffer</code> struct pointing to serialized bytes</td></tr>
<tr><td><code>enum</code> and <code>[Enum] interface</code></td><td><code>RustBuffer</code> struct pointing to serialized bytes</td></tr>
<tr><td><code>dictionary</code></td><td><code>RustBuffer</code> struct pointing to serialized bytes</td></tr>
<tr><td><code>interface</code></td><td><code>void*</code> opaque pointer to object on the heap</td></tr>
</tbody></table>
</div>
<h2 id="serialization-format"><a class="header" href="#serialization-format">Serialization Format</a></h2>
<p>When serializing complex data types into a byte buffer, UniFFI uses an
ad-hoc fixed-width format which is designed mainly for simplicity.
The details of this format are internal only and may change between versions of UniFFI.</p>
<div class="table-wrapper"><table><thead><tr><th>UDL Type</th><th>Representation in serialized bytes</th></tr></thead><tbody>
<tr><td><code>i8</code>/<code>i16</code>/<code>i32</code>/<code>i64</code></td><td>Fixed-width 1/2/4/8-byte signed integer, big-endian</td></tr>
<tr><td><code>u8</code>/<code>u16</code>/<code>u32</code>/<code>u64</code></td><td>Fixed-width 1/2/4/8-byte unsigned integer, big-endian</td></tr>
<tr><td><code>f32</code>/<code>float</code></td><td>Fixed-width 4-byte float, big-endian</td></tr>
<tr><td><code>f64</code>/<code>double</code></td><td>Fixed-width 8-byte double, big-endian</td></tr>
<tr><td><code>boolean</code></td><td>Fixed-width 1-byte signed integer, either <code>0</code> or <code>1</code></td></tr>
<tr><td><code>string</code></td><td>Serialized <code>i32</code> length followed by utf-8 string bytes; no trailing null</td></tr>
<tr><td><code>T?</code></td><td>If null, serialized <code>boolean</code> false; if non-null, serialized <code>boolean</code> true followed by serialized <code>T</code></td></tr>
<tr><td><code>sequence&lt;T&gt;</code></td><td>Serialized <code>i32</code> item count followed by serialized items; each item is a serialized <code>T</code></td></tr>
<tr><td><code>record&lt;string, T&gt;</code></td><td>Serialized <code>i32</code> item count followed by serialized items; each item is a serialized <code>string</code> followed by a serialized <code>T</code></td></tr>
<tr><td><code>enum</code> and <code>[Enum] interface</code></td><td>Serialized <code>i32</code> indicating variant, numbered in declaration order starting from 1, followed by the serialized values of the variant's fields in declaration order</td></tr>
<tr><td><code>dictionary</code></td><td>The serialized value of each field, in declaration order</td></tr>
<tr><td><code>interface</code></td><td>Fixed-width 8-byte unsigned integer encoding a pointer to the object on the heap</td></tr>
</tbody></table>
</div>
<p>Note that length fields in this format are serialized as <em>signed</em> integers
despite the fact that they will always be non-negative. This is to help
ease compatibility with JVM-based languages since the JVM uses signed 32-bit
integers for its size fields internally.</p>
<h2 id="code-generation-and-the-fficonverter-trait"><a class="header" href="#code-generation-and-the-fficonverter-trait">Code Generation and the FfiConverter trait</a></h2>
<p>UniFFI needs to generate Rust code to lift/lower types.  To help with this, we define the <code>FfiConverter</code> trait which contains the code to lift/lower/serialize a particular type.</p>
<p>The most straightforward approach would be to define <code>FfiConverter</code> on the type being lifted/lowered/serialized.  However, this wouldn't work for remote types defined in 3rd-party crates because of the Rust orphan rules.  For example, our crates can't implement <code>FfiConverter</code> on <code>serde_json::Value</code> because both the trait and the type are remote.</p>
<p>To work around this we do several things:</p>
<ul>
<li><code>FfiConverter</code> gets a generic type parameter.  This type is basically arbitrary and doesn't affect the lowering/lifting/serialization process.</li>
<li>We generate a unit struct named <code>UniFfiTag</code> in the root of each UniFFIed crate.</li>
<li>Each crate uses the <code>FfiConverter&lt;crate::UniFfiTag&gt;</code> trait to lower/lift/serialize values for its scaffolding functions.</li>
</ul>
<p>This allows us to work around the orphan rules when defining <code>FfiConverter</code> implementations.</p>
<ul>
<li>UniFFI consumer crates can implement lifting/lowering/serializing types for their own scaffolding functions, for example <code>impl FfiConverter&lt;crate::UniFfiTag&gt; for serde_json::Value</code>.  This is allowed since <code>UniFfiTag</code> is a local type.</li>
<li>The <code>uniffi</code> crate can implement lifting/lowering/serializing types for all scaffolding functions using a generic impl, for example <code>impl&lt;UT&gt; FfiConverter&lt;UT&gt; for u8</code>.  &quot;UT&quot; is short for &quot;UniFFI Tag&quot;</li>
<li>We don't currently use this, but crates can also implement lifting/lowering/serializing their local types for all scaffolding functions using a similar generic impl (<code>impl&lt;UT&gt; FfiConverter&lt;UT&gt; for MyLocalType</code>).</li>
</ul>
<p>For more details on the specifics of the &quot;orphan rule&quot; and why these are legal implementations, see the <a href="https://rust-lang.github.io/chalk/book/clauses/coherence.html#the-orphan-rules-in-rustc">Rust Chalk Book</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="managing-object-references"><a class="header" href="#managing-object-references">Managing Object References</a></h1>
<p>UniFFI <a href="internals/../udl/interfaces.html">interfaces</a> represent instances of objects
that have methods and contain state. One of Rust's core innovations
is its ability to provide compile-time guarantees about working with such instances,
including:</p>
<ul>
<li>Ensuring that each instance has a unique owner responsible for disposing of it.</li>
<li>Ensuring that there is only a single writer <em>or</em> multiple readers of an object
active at any point in the program.</li>
<li>Guarding against data races.</li>
</ul>
<p>The very nature of the problems UniFFI tries to solve is that calls may come
from foreign languages on any thread, outside of the control of Rust's ownership
system. UniFFI itself tries to take a hands-off approach as much as possible and
depends on the Rust compiler itself to uphold safety guarantees, without assuming
that foreign-language callers will be &quot;well behaved&quot;.</p>
<h2 id="concurrency"><a class="header" href="#concurrency">Concurrency</a></h2>
<p>UniFFI's hands-off approach means that all object instances exposed by UniFFI must be safe to
access concurrently. In Rust terminology, they must be <code>Send+Sync</code> and must be useable
without taking any <code>&amp;mut</code> references.</p>
<p>Typically this will mean that the Rust implementation of an object uses some of Rust's
data structures for thread-safe interior mutability, such as a <code>Mutex</code> or <code>RwLock</code> or
the types from <code>std::atomic</code>. The precise details are completely up to the author
of the component - as much as possible, UniFFI tries to stay out of your way, simply requiring
that the object implementation is <code>Send+Sync</code> and letting the Rust compiler ensure that
this is so.</p>
<h2 id="lifetimes"><a class="header" href="#lifetimes">Lifetimes</a></h2>
<p>In order to allow for instances to be used as flexibly as possible from foreign-language code,
UniFFI wraps all object instances in an <code>Arc</code> and leverages their reference-count based lifetimes,
allowing UniFFI to largely stay out of handling lifetimes entirely for these objects.</p>
<p>When constructing a new object, UniFFI is able to add the <code>Arc</code> automatically, because it
knows that the return type of the Rust constructor must be a new uniquely-owned struct of
the corresponding type.</p>
<p>When you want to return object instances from functions or methods, or store object instances
as fields in records, the underlying Rust code will need to work with <code>Arc&lt;T&gt;</code> directly, to ensure
that the code behaves in the way that UniFFI expects.</p>
<p>When accepting instances as arguments, the underlying Rust code can choose to accept it as an <code>Arc&lt;T&gt;</code>
or as the underlying struct <code>T</code>, as there are different use-cases for each scenario.</p>
<p>For example, given a interface definition like this:</p>
<pre><code class="language-idl">interface TodoList {
    constructor();
    void add_item(string todo);
    sequence&lt;string&gt; get_items();
};
</code></pre>
<p>On the Rust side of the generated bindings:</p>
<ul>
<li>The instance constructor will create an instance of the corresponding <code>TodoList</code> Rust struct</li>
<li>The owned value is wrapped in an <code>Arc&lt;&gt;</code></li>
<li>The <code>Arc&lt;&gt;</code> is lowered into the foreign code using <code>Arc::into_raw</code> and returned as an object pointer.</li>
</ul>
<p>This is the &quot;arc to pointer&quot; dance. Note that this has &quot;leaked&quot; the <code>Arc&lt;&gt;</code>
reference out of Rusts ownership system and given it to the foreign-language
code. The foreign-language code must pass that pointer back into Rust in order
to free it, or our instance will leak.</p>
<p>When invoking a method on the instance:</p>
<ul>
<li>The foreign-language code passes the raw pointer back to the Rust code, conceptually passing a &quot;borrow&quot; of the <code>Arc&lt;&gt;</code> to the Rust scaffolding.</li>
<li>The Rust side calls <code>Arc::from_raw</code> to convert the pointer into an an <code>Arc&lt;&gt;</code></li>
<li>It wraps the <code>Arc</code> in <code>std::mem::ManuallyDrop&lt;&gt;</code>, which we never actually
drop.  This is because the Rust side is borrowing the Arc and shouldn't
run the destructor and decrement the reference count.</li>
<li>The <code>Arc&lt;&gt;</code> is cloned and passed to the Rust code</li>
</ul>
<p>Finally, when the foreign-language code frees the instance, it
passes the raw pointer a special destructor function so that the Rust code can
drop that initial reference (and if that happens to be the final reference,
the Rust object will be dropped.).  This simply calls <code>Arc::from_raw</code>, then
lets the value drop.</p>
<p>Passing instances as arguments and returning them as values works similarly, except that
UniFFI does not automatically wrap/unwrap the containing <code>Arc</code>.</p>
<p>To see this in action, use <code>cargo expand</code> to see the exact generated code.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rendering-foreign-bindings"><a class="header" href="#rendering-foreign-bindings">Rendering Foreign Bindings</a></h1>
<p>This document details the general system that UniFFI uses to render the foreign bindings code.</p>
<h2 id="the-askama-template-engine"><a class="header" href="#the-askama-template-engine">The Askama template engine</a></h2>
<p>Our foreign bindings generation uses the <a href="https://djc.github.io/askama/">Askama</a> template rendering engine. Askama uses
a compile-time macro system that allows the template code to use Rust types directly, calling their methods passing them
to normal Rust functions.</p>
<p>The task of the templates is to render the <code>ComponentInterface</code>, which is the Rust representation of the UDL file, into
a bindings source file.  This mainly consists of rendering source code for each <code>Type</code> from the UDL.</p>
<h2 id="type-matching"><a class="header" href="#type-matching">Type matching</a></h2>
<p>One of the main sources of complexity when generating the bindings is handling types.  UniFFI supports a large number of
types, each of which corresponds to a variant of the <a href="internals/./api/uniffi_bindgen/interface/types/enum.Type.html"><code>Type enum</code></a>.
At one point there was a fairly large number of &quot;mega-match&quot; functions, each one matching against all <code>Type</code> variants.
This made the code difficult to understand, because the functionality for one kind of type was split up.</p>
<p>Our current system for handling this is to have exactly 2 matches against <code>Type</code>:</p>
<ul>
<li>One match lives in the template code.  We map each <code>Type</code> variant to a template file that renders definitions and
helper code, including:
<ul>
<li>Class definitions for records, enums, and objects.</li>
<li>Base classes and helper classes, for example
<a href="https://github.com/mozilla/uniffi-rs/blob/main/uniffi_bindgen/src/bindings/kotlin/templates/ObjectRuntime.kt"><code>ObjectRuntime.kt</code></a>
contains shared functionality for all the <code>Type::Object</code> types.</li>
<li>The FfiConverter class definition.  This handles <a href="internals/./lifting_and_lowering.html">lifting and lowering
types across the FFI</a> for the type.</li>
<li>Initialization functions</li>
<li>Importing dependencies</li>
<li>See
<a href="https://github.com/mozilla/uniffi-rs/blob/main/uniffi_bindgen/src/bindings/kotlin/templates/Types.kt"><code>Types.kt</code></a>
for an example.</li>
</ul>
</li>
<li>The other match lives in the Rust code.  We map each <code>Type</code> variant to a implementation of the <code>CodeType</code> trait that
renders identifiers and names related to the type, including:
<ul>
<li>The name of the type in the foreign language</li>
<li>The name of the <code>FfiConverter</code> class</li>
<li>The name of the initialization function</li>
<li>See
<a href="https://github.com/mozilla/uniffi-rs/blob/470740289258e1f06171a976d8e15978f028e391/uniffi_bindgen/src/bindings/kotlin/gen_kotlin/mod.rs#L198-L230"><code>KotlinCodeOracle::create_code_type()</code></a>
for an example.</li>
</ul>
</li>
</ul>
<p>Why is the code organized like this?  For a few reasons:</p>
<ul>
<li><strong>Defining Askama templates in Rust required a lot of boilerplate.</strong>  When the Rust code was responsible for
rendering the class definitions, helper classes, etc., it needed to define a lot of <code>Askama</code> template structs which
lead to a lot of extra lines of code (see PR <a href="https://github.com/mozilla/uniffi-rs/pull/1189">#1189</a>)</li>
<li><strong>It's easier to access global state from the template code.</strong>  Since the Rust code only handles names and
identifiers, it only needs access to the <code>Type</code> instance itself, not the
<a href="internals/./api/uniffi_bindgen/interface/struct.ComponentInterface.html"><code>ComponentInterface</code></a> or the
<a href="internals/./api/uniffi_bindgen/struct.Config.html"><code>Config</code></a>.  This simplifies the Rust side of things (see PR <a href="https://github.com/mozilla/uniffi-rs/pull/1191">#1191</a>).
Accessing the <code>ComponentInterface</code> and <code>Config</code> from the template code is easy, we simply define these as fields on
the top-level template Struct then they are accessible from all child templates.</li>
<li><strong>Putting logic in the template code makes it easier to implement <a href="internals/../udl/ext_types_external.html">external types</a>.</strong>  For
example, at one point the logic to lift/lower a type lived in the Rust code as a function that generated the
expression in the foreign language.  However, it was not clear at all how to make this work for external types,
it would probably require parsing multiple UDL files and managing multiple ComponentInterfaces.  Putting the logic
to lift/lower the type in the <code>FfiConverter</code> class simplifies this, because we can import the external
<code>FfiConverter</code> class and use that. We only need to know the name of the <code>FfiConverter</code> class which is a simpler
task.</li>
</ul>
<h2 id="askama-extensions"><a class="header" href="#askama-extensions">Askama extensions</a></h2>
<p>A couple parts of this system require us to &quot;extend&quot; the functionality of Askama (i.e. adding hacks to workaround its
limitations).</p>
<h3 id="adding-imports"><a class="header" href="#adding-imports">Adding imports</a></h3>
<p>We want our type template files to specify what needs to be imported, but we don't want it to render the import
statements directly. The imports should be rendered at the top of the file and de-duped in case multiple types require
the same import. We handle this by:</p>
<ul>
<li>Defining a separate Askama template struct that loops over all types and renders the definition/helper code for them.</li>
<li>That struct also stores a <code>BTreeSet</code> that contains the needed import statements and has an <code>add_import()</code> method that
the template code calls.  Using a <code>BTreeSet</code> ensures the imports stay de-duped and sorted.</li>
<li>Rendering this template as a separate pass.  The rendered string and the list of imports get passed to the main
template which arranges for them to be placed in the correct location.</li>
</ul>
<h3 id="including-templates-once"><a class="header" href="#including-templates-once">Including templates once</a></h3>
<p>We want our type template files to render runtime code, but only once.  For example, we only want to render
<code>ObjectRuntime.kt</code> once, even if there are multiple Object types defined in the UDL file.  To handle this the type
template defines an <code>include_once_check()</code> method, which tests if we've included a file before.  The template code then
uses that to guard the Askama <code>{% include %}</code> statement.  See <a href="https://github.com/mozilla/uniffi-rs/blob/470740289258e1f06171a976d8e15978f028e391/uniffi_bindgen/src/bindings/kotlin/templates/ObjectTemplate.kt#L2"><code>Object.kt</code> for an
example</a></p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
